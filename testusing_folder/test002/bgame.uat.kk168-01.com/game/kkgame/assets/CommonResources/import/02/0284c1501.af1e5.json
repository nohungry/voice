[1,["ecpdLyjvZBwrvm+cedCcQy","a5hJI5OtNB0Yq0rp/qEfl/","e7q6FL+VZEgLJUjVeDLic/","abL93pEMJE5L/h/PzBqGqp","9bvaMerUlDyary99mJa6xp","1aMvx28L1PZpgPVpKcDKCz","f0BIwQ8D5Ml7nTNQbh1YlS","04bxcsFXRIi7u4ZBWprblt","29FYIk+N1GYaeWH/q1NxQO","b4MM6jarNBBrBzJsaYkY7d","abwstieFJFJakN1HRIe4jy","839e/4M4VPlZt2jaCqHZbN","7aF95uInpGsYAJ5xV9TTrP","a17y/JnFdBio9pa+2aeg5/","e9PT+pjCFDdYohFLqEBmx3","3bvbD2xfZF3p8zi1y6+01t","14x0hpvbRPV4bYp4dd4r4w","312JYturtOx74Zjp9UpOqZ","68J8oyAQdFUrqy37MXmbtE","90AErWL21A4ZPvtxQ3XG8G","e97GVMl6JHh5Ml5qEDdSGa","ffDpHHVcZAhqOfy25Fe4w7","675ovJ2tVK2aLYfgPUWOMv","8855/VlrRKd6H0MSRnFxAU","c9+lH/PwFGAY+AMl0bEdq3","5cO7kybDxGj4ipyMYdRYZB","5f5dyqtRNNxaFmVzYns6FZ","8c20Sso/ZEn7NUfNSM+EBh","a2MjXRFdtLlYQ5ouAFv/+R","bbQu2OCGdFhK1jtvhPg7uo","b2aHrECZ5APKGS/0d2hvT1","43L6CczwNM/6GGmCYEQIoH","9dYAAftfRHJqYpJlnj3tC4","11UobRLhBJ7qq0NBWD9gfo","43Dsy/vyxObowMiEu7SH8y","6cXPbhsEROrJQxg1ZE1XOB","e28ACFxZdCLZdZUsNgJ5EG","71aNtiDtxC5b5daCz2xKFl","7dT/2UQtZARZ23p0Qimt/E","43APlBugNNGb2xlZ70DxhS","c4SAoKasVEP4tANhoUJX/I","a8fMFHAbJD+I5Cp8qQsMdX","feFBe2/mtGpK58n9Mx8zoq","b5/CzyeUJIPb4fu+rcRxSt","1cXkA4lTpEwrYgC7/GFwR3","3fN2ElpplAyq0FBNZi6qHy","6cnvENtHlCC7/mOc3aaorg","2dmkuFsKtMRoTFGPOTqyBY","deUQB2BWtIT7lMg77yF9Dh","95T+yLzRZLuaO3dxlmDnVY","a5ebYQCqdKi7NrvjTMg03M","b8IjYZfjhHxIQfkWDCMkla","47LfXTNedBhJ5sf0G+5l7j","61kG2jcANL2pq8V2nHb67k","dduZs5cARHzZcFdRkFxDxG","0c8wKEkHNGvJ665itp27/z","f5Mx/Sv0JO46P9PhZXYA7/","89fvehSGBPZJaN9ZJLGGaK","70182wBM1Bu5SAwGpHhfOG","70u+tzbcJO5I+vdrOg407E","ediPE9/K1ISKo1ZaLLlzWE","97K5pNR+5MdLXDYdimm8Kf","2ck3YIJWJA6rJkc5Xfbwzq","61rrBbOzJFK47tK3be7tVU","27dW67PTNEsJuW6Fj63U3U","78WkQsPOtFvqRucxf2JfO5","cahAH+rW5BqL1Gjj5OmUW+","cdM+3qVfVGwpWNNXoBOEo2","59Zf+sadpLVbzekiXQYTwo","4aN91XeM1M7KrU8Rpz0Stj","32BEvSSB9M8aZW4rL7FZTr","00BNHPoK1H2KsXNNPbnTWj","96CD0DwzJKP5OG0D4tGeju","1fVeO+uJtLeYjeR/0xAYBE","7d4DqARFdDjZWnPnzf/WCG","0eQrqVH6FGqrLPFDzRvO4s","0deElj0CROpqfbA74K1jAQ","bfCkNMhN1KjqCKejbxgMx1","d1uL5JsKBDXIO3VSvtS741","8cUAH9B+5KS6igY+FRlelN","30aC+Hnw1PF4pEcoY3kUYb","14TDKXr2NJ6LjvHPops74o","f1h0LXVtJOta5JLZ1xCzfI","0ek66qC1NOQLjgYmi04HvX","28dPjdQWxEQIG3VVl1Qm6T","82migssElAGb04Ws6NimQX","2afAA24LNP4YmYiaVLiivs","c0BAyVxX9JzZy8EjFrc9DU","6dkeWRTOBGXICfYQ7JUBnG","6fgBCSDDdPMInvyNlggls2","a1U5RdJRFMFL57BdJC9H1X","3ae7efMv1CLq2ilvUY/tQi","e0LYfU5ZlNFoAB4UiRrGUG","7a/QZLET9IDreTiBfRn2PD","46bU+b5fROqIXVPG6aZWWK","cffgu4qBxEqa150o1DmRAy","2aKWBXJHxKHLvrBUi2yYZQ","02kcE0s9pAmLe145ftvpR/","60AwGqM1dKELCGhPAR+jK6","cf73jxyN9Jt47QTJU6ziYh","d2kHe6FidKcpV5e1aiNTQM","c2W51QyPxNJ77rbnwfLlwP","b1gcHkCnJKkb+wrm82ymC9","99FwsL0hBG8bITfZ4/IwmK","6eBWFz0oVHPLIGQKf/9Thu","73oJA92A5OPKpn+ZlUPAj1","02delMVqdBD70a/HSD99FK","8alrllLcBOA6qQO3nLk7W0","4bq2fLGOZAmbhANV8Ec/iQ","56fc2Ai/RFNYpaMT8crweK"],["node","root","data","_spriteFrame","_mesh","_textureSetter","asset","_N$target","checkMark","toggleGroup","_N$normalSprite","_N$pressedSprite","_N$hoverSprite","_N$disabledSprite","_parent","_effectAsset","spriteFrame","_N$handle","_scrollView","_N$barSprite","_N$background","_N$placeholderLabel","_N$textLabel","_pageView","_file"],[["cc.Node",["_name","_objFlags","_is3DNode","_prefab","_components","_trs","_parent","_contentSize","_children","_anchorPoint","_color","_eulerAngles"],0,4,9,7,1,5,2,5,5,5],"cc.SpriteFrame",["cc.Sprite",["_sizeMode","_type","_isTrimmedMode","node","_spriteFrame","_materials"],0,1,6,3],["cc.Node",["_name","_objFlags","_active","_components","_prefab","_contentSize","_parent","_anchorPoint","_trs","_children","_color"],0,12,4,5,1,5,7,2,5],["cc.Node",["_name","_objFlags","_active","_components","_prefab","_contentSize","_parent","_trs","_anchorPoint","_children"],0,2,4,5,1,7,5,2],["cc.Label",["_string","_N$verticalAlign","_fontSize","_N$horizontalAlign","_lineHeight","_enableWrapText","_N$overflow","_N$cacheMode","node","_materials"],-5,1,3],["cc.PrefabInfo",["fileId","root","asset"],2,1,6],["cc.Toggle",["_N$transition","_N$isChecked","node","_N$normalColor","_N$target","checkMark","toggleGroup"],1,1,5,1,1,1],["cc.Widget",["_alignFlags","alignMode","_originalHeight","_left","_originalWidth","node"],-2,1],["cc.Light",["_shadowMaxDepth","_shadowFrustumSize","_type","_intensity","_range","node"],-2,1],["cc.Camera",["_clearFlags","_depth","_farClip","_ortho","_alignWithScreen","_nearClip","node"],-3,1],["cc.Prefab",["_name","optimizationPolicy"],1],["cc.Button",["_N$transition","zoomScale","_N$enableAutoGrayEffect","node","_N$pressedColor","_N$disabledColor","_N$target","_N$normalColor","_N$normalSprite","_N$pressedSprite","_N$hoverSprite","_N$disabledSprite"],0,1,5,5,1,5,6,6,6,6],["cc.BufferRange",["length","offset"],1],["cc.CurveRange",["constant"],2],["cc.Layout",["_resize","_N$layoutType","_N$spacingY","node","_layoutSize"],0,1,5],["cc.Slider",["node","_N$handle"],3,1,1],["cc.Mesh",["_native","_vertexBundles","_primitives","_minPos","_maxPos"],2,9,9,5,5],["cc.mesh.VertexBundle",["verticesCount","data","formats"],2,4,9],["cc.mesh.VertexFormat",["name","type","num"],0],["cc.mesh.Primitive",["vertexBundleIndices","data"],2,4],["cc.TiledTile",["node"],3,1],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.MeshRenderer",["node","_materials","_mesh"],3,1,3,6],["084cat4fn5FEbYo5LUbPQiN",["node","asset"],3,1,3],["cc.Canvas",["node"],3,1],["cc.Mask",["_N$alphaThreshold","node","_materials"],2,1,3],["cc.Scrollbar",["_N$direction","node","_N$handle"],2,1,1],["cc.ScrollView",["horizontal","brake","bounceDuration","_N$horizontalScrollBar","node","_N$content","_N$verticalScrollBar"],-1,1,1,1],["cc.RichText",["_N$lineHeight","node"],2,1],["cc.ProgressBar",["_N$totalLength","_N$progress","node","_N$barSprite"],1,1,1],["cc.EditBox",["maxLength","_N$inputMode","node","_N$textLabel","_N$placeholderLabel","_N$background"],1,1,1,1,1],["cc.ParticleSystem3D",["node","_materials","startDelay","startLifetime","startColor","startSize","startSpeed","startRotation","gravityModifier","rateOverTime","rateOverDistance","_shapeModule"],3,1,3,4,4,4,4,4,4,4,4,4,4],["cc.GradientRange",[],3],["cc.ShapeModule",["enable","emitFrom","arcSpeed"],1,4],["cc.TiledMap",["node"],3,1],["cc.WebView",["node"],3,1],["cc.Model",["_name","_nodes"],1],["cc.BufferAsset",["_name","_native"],1],["cc.Material",["_techniqueData"],3,11],["cc.Material",["_name","_techniqueData"],1],["cc.ParticleAsset",["_name","_native"],1],["cc.ToggleContainer",["node"],3,1],["cc.PageViewIndicator",["spacing","node","cellSize"],2,1,5],["cc.PageView",["bounceDuration","node","_N$content","_N$indicator"],2,1,1,1],["cc.ParticleSystem",["node","_startColor","_startColorVar","_endColor","_endColorVar","_file"],3,1,8,8,8,8,6],["cc.ToggleGroup",["node"],3,1]],[[6,0,1,2],[19,0,1,2,4],[11,0,2],[11,0,1,3],[23,0,1,2,1],[2,1,0,3,5,4,3],[0,0,1,6,4,3,7,3],[0,0,2,4,3,3],[0,0,2,6,4,3,5,11,3],[6,0,1,2,2],[17,0,1,2,3,4,2],[18,0,1,2,2],[13,0,2],[13,1,0,3],[20,0,1,2],[0,0,8,4,3,7,2],[0,0,4,3,7,5,2],[0,0,6,8,4,3,7,5,2],[2,0,2,3,5,4,3],[0,0,2,4,3,5,3],[22,0,1,2,4],[14,1],[0,0,4,3,5,2],[4,0,1,2,6,3,4,5,4],[2,0,2,3,3],[14,0,2],[0,0,1,6,8,4,3,7,3],[0,0,1,6,4,3,10,7,5,3],[4,0,1,6,3,4,5,3],[2,0,2,3,5,3],[2,1,0,3,5,3],[0,0,2,8,3,3],[3,0,1,6,3,4,5,3],[4,0,1,6,3,4,5,8,7,3],[4,0,9,3,4,5,2],[9,2,0,1,5,4],[9,2,3,4,0,1,5,6],[9,0,1,5,3],[7,0,2,3,4,5,2],[7,0,1,2,3,4,5,3],[7,0,1,2,3,4,6,5,3],[8,1,0,4,2,5,5],[8,1,0,3,4,2,5,6],[10,2,3,4,6,4],[26,0,1,2,2],[0,0,4,3,2],[0,0,8,4,3,7,5,2],[0,0,6,4,3,5,2],[0,0,1,8,3,7,9,5,3],[0,0,1,6,4,3,10,7,9,5,3],[0,0,1,6,4,3,10,7,3],[0,0,2,4,3,5,11,3],[0,0,1,8,4,3,7,9,5,3],[0,0,1,2,6,4,3,5,4],[0,0,1,2,6,4,3,5,11,4],[0,0,1,2,6,4,3,4],[0,0,2,6,4,3,3],[3,0,9,3,4,5,2],[3,0,1,6,9,3,4,5,7,8,3],[3,0,1,2,6,3,4,5,7,8,4],[3,0,1,6,3,4,10,5,7,8,3],[4,0,1,6,3,4,5,7,3],[16,0,1,1],[6,1,1],[6,1,2,1],[2,3,5,4,1],[2,0,3,4,2],[2,1,0,3,4,3],[2,3,4,1],[12,1,2,0,3,4,5,6,4],[12,0,3,7,4,5,6,8,9,10,11,2],[7,0,2,3,4,6,5,2],[21,0,1],[24,0,1,1],[5,0,3,1,8,4],[5,0,2,4,3,8,9,5],[5,2,4,5,1,6,8,6],[5,0,2,4,5,1,6,8,9,7],[5,0,2,5,3,1,6,7,8,9,8],[25,0,1],[8,0,5,2],[8,1,0,3,2,5,5],[10,0,1,6,3],[10,5,6,2],[27,0,1,2,2],[28,0,1,2,3,4,5,6,5],[29,0,1,2],[30,0,1,2,3,3],[31,0,1,2,3,4,5,3],[32,0,1,2,3,4,5,6,7,8,9,10,11,1],[33,1],[34,0,1,2,3],[15,3,4,1],[15,0,1,2,3,4,4],[35,0,1],[36,0,1],[37,0,1,3],[38,0,1,3],[39,0,1],[40,0,1,3],[41,0,1,3],[42,0,1],[43,0,1,2,2],[44,0,1,2,3,2],[45,0,1,2,3,4,5,1],[46,0,1]],[[[[3,"slider",1],[15,"slider",[-4,-5],[[62,-3,-2]],[0,"8ac42iRpDlK6pemd22ZO6x/",-1],[5,300,20]],[32,"Handle",512,1,[[[5,1,2,-6,[2],3],-7],4,1],[0,"93f4b6UTvtD0Iy5hi3tLIn2",1],[5,32,32]],[6,"Background",512,1,[[5,1,0,-8,[0],1]],[0,"f43c4gNvOtBE41OTztiOT6T",1],[5,300,20]],[69,1.1,true,3,2,[4,4294967295],[4,4294967295],2]],0,[0,1,1,0,17,4,0,0,1,0,-1,3,0,-2,2,0,0,2,0,-2,4,0,0,3,0,2,1,8],[0,0,0,0,4,4,4,4],[-1,3,-1,3,10,11,12,13],[0,17,0,2,2,2,2,8]],[[[10,".bin",[[11,24,[12,768],[[1,"a_normal",5126,3],[1,"a_position",5126,3],[1,"a_uv0",5126,2]]]],[[14,[0],[13,768,72]]],[1,-0.5,-0.5,-0.5],[1,0.5,0.5,0.5]],-1],0,0,[],[],[]],[[[2,"point"],[19,"light",true,[[35,1,1000,50,-2]],[0,"33zOkteexCqamZ4PXuwJaW",-1],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[[3,"toggle",1],[15,"toggle",[-5,-6],[[38,3,-4,[4,4292269782],-3,-2]],[0,"3d81aISgHdGFblE/PZD2Cp3",-1],[5,28,28]],[6,"Background",512,1,[[65,-7,[0],1]],[0,"238bacn/jZGGYuFN7ndSzkO",1],[5,28,28]],[28,"checkmark",512,1,[-8],[0,"0d447hRg/9AuLVwR7+lDw/1",1],[5,28,28]],[29,2,false,3,[2]]],0,[0,1,1,0,8,4,0,7,2,0,0,1,0,-1,2,0,-2,3,0,0,2,0,-1,4,0,2,1,8],[0,0,0,4],[-1,3,-1,3],[0,18,0,19]],[[[2,"tiledtile"],[22,"New TiledTile",[[72,-2]],[0,"fb1JS09SVFapQy1+PoRN4F",-1],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[[20,"__builtin-editor-gizmo",[{"hash":2992916359,"record":null,"name":"__builtin-editor-gizmo|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nvarying vec3 v_worldNormal;\nvarying vec3 v_worldPosition;\nvarying vec3 v_localPosition;\nvarying vec3 v_right;\nvarying vec3 v_up;\nvarying vec3 v_forward;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  v_localPosition = a_position;\n  v_worldPosition = (cc_matWorld * pos).xyz;\n  v_worldNormal = (cc_matWorldIT * vec4(a_normal, 0)).xyz;\n  v_right = vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]);\n  v_up = vec3(cc_matView[0][1], cc_matView[1][1], cc_matView[2][1]);\n  v_forward = vec3(cc_matView[0][2], cc_matView[1][2], cc_matView[2][2]);\n  gl_Position = cc_matViewProj * cc_matWorld * pos;\n}","frag":"\nprecision highp float;\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\nmat3 transpose(mat3 v) {\n    mat3 tmp;\n    tmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n    tmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n    tmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n    return tmp;\n}\nvoid ClipQuadToHorizon(inout vec3 L[5], out int n) {\n    int config = 0;\n    if (L[0].z > 0.0) config += 1;\n    if (L[1].z > 0.0) config += 2;\n    if (L[2].z > 0.0) config += 4;\n    if (L[3].z > 0.0) config += 8;\n    config = 15;\n    n = 0;\n    if (config == 0)\n    {\n    }\n    else if (config == 1)\n    {\n        n = 3;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 2)\n    {\n        n = 3;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 3)\n    {\n        n = 4;\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n        L[3] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 4)\n    {\n        n = 3;\n        L[0] = -L[3].z * L[2] + L[2].z * L[3];\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n    }\n    else if (config == 5)\n    {\n        n = 0;\n    }\n    else if (config == 6)\n    {\n        n = 4;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 7)\n    {\n        n = 5;\n        L[4] = -L[3].z * L[0] + L[0].z * L[3];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 8)\n    {\n        n = 3;\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n        L[1] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] =  L[3];\n    }\n    else if (config == 9)\n    {\n        n = 4;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[2].z * L[3] + L[3].z * L[2];\n    }\n    else if (config == 10)\n    {\n        n = 0;\n    }\n    else if (config == 11)\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 12)\n    {\n        n = 4;\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n    }\n    else if (config == 13)\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = L[2];\n        L[2] = -L[1].z * L[2] + L[2].z * L[1];\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n    }\n    else if (config == 14)\n    {\n        n = 5;\n        L[4] = -L[0].z * L[3] + L[3].z * L[0];\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n    }\n    else if (config == 15)\n    {\n        n = 4;\n    }\n    if (n == 3)\n        L[3] = L[0];\n    if (n == 4)\n        L[4] = L[0];\n}\nfloat IntegrateEdge(vec3 v1, vec3 v2) {\n    float cosTheta = dot(v1, v2);\n    float theta = acos(cosTheta);\n    return cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 4.0);\n}\nvec3 LTC_Evaluate(vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4]) {\n    vec3 T1, T2;\n    T1 = normalize(V - N*dot(V, N));\n    T2 = cross(N, T1);\n    Minv = Minv * transpose(mat3(T1, T2, N));\n    vec3 L[5];\n    L[0] = Minv * (points[0] - P);\n    L[1] = Minv * (points[1] - P);\n    L[2] = Minv * (points[2] - P);\n    L[3] = Minv * (points[3] - P);\n    int n;\n    ClipQuadToHorizon(L, n);\n    if (n == 0)\n        return vec3(0, 0, 0);\n    L[0] = normalize(L[0]);\n    L[1] = normalize(L[1]);\n    L[2] = normalize(L[2]);\n    L[3] = normalize(L[3]);\n    L[4] = normalize(L[4]);\n    float sum = 0.0;\n    sum += IntegrateEdge(L[0], L[1]);\n    sum += IntegrateEdge(L[1], L[2]);\n    sum += IntegrateEdge(L[2], L[3]);\n    if (n >= 4)\n        sum += IntegrateEdge(L[3], L[4]);\n    if (n == 5)\n        sum += IntegrateEdge(L[4], L[0]);\n    sum = max(0.0, sum);\n    vec3 Lo_i = vec3(sum, sum, sum);\n    return Lo_i;\n}\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform DIFFUSE_COLOR {\n  vec4 diffuseColor;\n};\nvarying vec3 v_worldNormal;\nvarying vec3 v_worldPosition;\nvarying vec3 v_localPosition;\nvarying vec3 v_right;\nvarying vec3 v_up;\nvarying vec3 v_forward;\nvoid main () {\n  vec3 N = normalize(v_worldNormal);\n  vec3 V = normalize(cc_cameraPos.xyz - v_worldPosition);\n  vec3 points[4];\n  vec3 up = vec3(0, 1, 0);\n  points[0] = (v_forward * 3.0 + v_right + up) * 40.0;\n  points[1] = (v_forward * 3.0 - v_right + up) * 40.0;\n  points[2] = (v_forward * 3.0 - v_right - up) * 40.0;\n  points[3] = (v_forward * 3.0 + v_right - up) * 40.0;\n  vec3 diffuse = diffuseColor.rgb * (0.2 + LTC_Evaluate(N, V, v_localPosition, mat3(1), points) * 0.8);\n  gl_FragColor = CCFragOutput(vec4(diffuse, diffuseColor.a));\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\nvarying vec3 v_worldNormal;\nvarying vec3 v_worldPosition;\nvarying vec3 v_localPosition;\nvarying vec3 v_right;\nvarying vec3 v_up;\nvarying vec3 v_forward;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  v_localPosition = a_position;\n  v_worldPosition = (cc_matWorld * pos).xyz;\n  v_worldNormal = (cc_matWorldIT * vec4(a_normal, 0)).xyz;\n  v_right = vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]);\n  v_up = vec3(cc_matView[0][1], cc_matView[1][1], cc_matView[2][1]);\n  v_forward = vec3(cc_matView[0][2], cc_matView[1][2], cc_matView[2][2]);\n  gl_Position = cc_matViewProj * cc_matWorld * pos;\n}","frag":"\nprecision highp float;\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\nmat3 transpose(mat3 v) {\n    mat3 tmp;\n    tmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n    tmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n    tmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n    return tmp;\n}\nvoid ClipQuadToHorizon(inout vec3 L[5], out int n) {\n    int config = 0;\n    if (L[0].z > 0.0) config += 1;\n    if (L[1].z > 0.0) config += 2;\n    if (L[2].z > 0.0) config += 4;\n    if (L[3].z > 0.0) config += 8;\n    config = 15;\n    n = 0;\n    if (config == 0)\n    {\n    }\n    else if (config == 1)\n    {\n        n = 3;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 2)\n    {\n        n = 3;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 3)\n    {\n        n = 4;\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n        L[3] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 4)\n    {\n        n = 3;\n        L[0] = -L[3].z * L[2] + L[2].z * L[3];\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n    }\n    else if (config == 5)\n    {\n        n = 0;\n    }\n    else if (config == 6)\n    {\n        n = 4;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 7)\n    {\n        n = 5;\n        L[4] = -L[3].z * L[0] + L[0].z * L[3];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 8)\n    {\n        n = 3;\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n        L[1] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] =  L[3];\n    }\n    else if (config == 9)\n    {\n        n = 4;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[2].z * L[3] + L[3].z * L[2];\n    }\n    else if (config == 10)\n    {\n        n = 0;\n    }\n    else if (config == 11)\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 12)\n    {\n        n = 4;\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n    }\n    else if (config == 13)\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = L[2];\n        L[2] = -L[1].z * L[2] + L[2].z * L[1];\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n    }\n    else if (config == 14)\n    {\n        n = 5;\n        L[4] = -L[0].z * L[3] + L[3].z * L[0];\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n    }\n    else if (config == 15)\n    {\n        n = 4;\n    }\n    if (n == 3)\n        L[3] = L[0];\n    if (n == 4)\n        L[4] = L[0];\n}\nfloat IntegrateEdge(vec3 v1, vec3 v2) {\n    float cosTheta = dot(v1, v2);\n    float theta = acos(cosTheta);\n    return cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 4.0);\n}\nvec3 LTC_Evaluate(vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4]) {\n    vec3 T1, T2;\n    T1 = normalize(V - N*dot(V, N));\n    T2 = cross(N, T1);\n    Minv = Minv * transpose(mat3(T1, T2, N));\n    vec3 L[5];\n    L[0] = Minv * (points[0] - P);\n    L[1] = Minv * (points[1] - P);\n    L[2] = Minv * (points[2] - P);\n    L[3] = Minv * (points[3] - P);\n    int n;\n    ClipQuadToHorizon(L, n);\n    if (n == 0)\n        return vec3(0, 0, 0);\n    L[0] = normalize(L[0]);\n    L[1] = normalize(L[1]);\n    L[2] = normalize(L[2]);\n    L[3] = normalize(L[3]);\n    L[4] = normalize(L[4]);\n    float sum = 0.0;\n    sum += IntegrateEdge(L[0], L[1]);\n    sum += IntegrateEdge(L[1], L[2]);\n    sum += IntegrateEdge(L[2], L[3]);\n    if (n >= 4)\n        sum += IntegrateEdge(L[3], L[4]);\n    if (n == 5)\n        sum += IntegrateEdge(L[4], L[0]);\n    sum = max(0.0, sum);\n    vec3 Lo_i = vec3(sum, sum, sum);\n    return Lo_i;\n}\nuniform vec4 cc_cameraPos;\nuniform vec4 diffuseColor;\nvarying vec3 v_worldNormal;\nvarying vec3 v_worldPosition;\nvarying vec3 v_localPosition;\nvarying vec3 v_right;\nvarying vec3 v_up;\nvarying vec3 v_forward;\nvoid main () {\n  vec3 N = normalize(v_worldNormal);\n  vec3 V = normalize(cc_cameraPos.xyz - v_worldPosition);\n  vec3 points[4];\n  vec3 up = vec3(0, 1, 0);\n  points[0] = (v_forward * 3.0 + v_right + up) * 40.0;\n  points[1] = (v_forward * 3.0 - v_right + up) * 40.0;\n  points[2] = (v_forward * 3.0 - v_right - up) * 40.0;\n  points[3] = (v_forward * 3.0 + v_right - up) * 40.0;\n  vec3 diffuse = diffuseColor.rgb * (0.2 + LTC_Evaluate(N, V, v_localPosition, mat3(1), points) * 0.8);\n  gl_FragColor = CCFragOutput(vec4(diffuse, diffuseColor.a));\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"OUTPUT_TO_GAMMA","type":"boolean","defines":[]}],"blocks":[{"name":"DIFFUSE_COLOR","binding":0,"members":[{"name":"diffuseColor","type":16,"count":1}],"defines":[]}],"samplers":[]}],[{"passes":[{"stage":"transparent","program":"__builtin-editor-gizmo|vs|fs","blendState":{"targets":[{"blend":true,"blendEq":32774,"blendAlphaEq":32774,"blendSrcAlpha":1,"blendDstAlpha":771}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"diffuseColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}}}}]}]]],0,0,[],[],[]],[[[10,".bin",[[11,1089,[12,34848],[[1,"a_normal",5126,3],[1,"a_position",5126,3],[1,"a_uv0",5126,2]]]],[[14,[0],[13,34848,12288]]],[1,-0.5,-0.0999999940395355,-0.5],[1,0.5,0.0999999940395355,0.5]],-1],0,0,[],[],[]],[[{"name":"default_radio_button_on","rect":[1,1,30,30],"offset":[0,0],"originalSize":[32,32],"capInsets":[0,0,0,0]}],[1],0,[0],[5],[32]],[[[2,"cylinder"],[7,"cylinder",true,[[4,-2,[0],1]],[0,"3dlUtIqQhGCrx5Sishojtq",-1]]],0,[0,1,1,0,0,1,0,2,1,2],[0,0],[-1,4],[1,9]],[[[2,"CocosDefaultAssets"],[45,"CocosDefaultAssets",[[73,-2,[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95]]],[63,-1]]],0,[0,1,1,0,0,1,0,2,1,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96],[33,34,35,10,36,8,6,20,21,4,22,23,2,5,17,24,25,26,27,28,19,37,18,38,39,40,41,42,43,44,45,46,47,48,49,7,50,11,12,9,1,13,3,14,15,16,29,51,52,30,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,0,31,94,95,96]],[[[3,"sprite_splash",1],[16,"New Sprite (Splash)",[[66,0,-2,0]],[0,"1a0f4zwu2VOapqEJkWXIF0R",-1],[5,100,100],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[0],[3],[28]],[[[3,"label",1],[16,"Label",[[74,"Label",1,1,-2]],[0,"d1cddH/doRNQ4Aodz8556bh",-1],[5,128,50],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[[3,"canvas",1],[46,"Canvas",[-4],[[79,-2],[80,45,-3]],[0,"a6aa1W/pshGFZkMhhqxkZYP",-1],[5,960,640],[480,320,0,0,0,0,1,1,1,1]],[47,"Main Camera",1,[[82,7,-1,-5]],[0,"d2xIc1y/ZF6Kn7K3yqwDJm",1],[0,0,365.46272039703314,0,0,0,1,1,1,1]]],0,[0,1,1,0,0,1,0,0,1,0,-1,2,0,0,2,0,2,1,5],[],[],[]],[[[2,"sphere"],[7,"sphere",true,[[4,-2,[0],1]],[0,"e0chObmn1N5q+1kVoqVegu",-1]]],0,[0,1,1,0,0,1,0,2,1,2],[0,0],[-1,4],[1,15]],[[{"name":"default_scrollbar","rect":[0,0,30,15],"offset":[0,0],"originalSize":[30,15],"capInsets":[10,4,10,4]}],[1],0,[0],[5],[97]],[[[3,"scrollview",1],[57,"scrollview",[-4,-5],[[[5,1,0,-2,[5],6],-3],4,1],[0,"2bb72ntvphNH4HtVfnSNUVp",-1],[5,240,250]],[58,"scrollBar",512,1,[-9],[[-6,[81,0,37,350.07654921020657,237,-7],[5,1,0,-8,[3],4]],1,4,4],[0,"f8b835eFHxKj4uMGeoBGz+U",1],[5,12,250],[0,1,0.5],[120,0,0,0,0,0,1,1,1,1]],[48,"content",512,[-10],[0,"036a4WKD5hBcbQJmMrbqoW8",1],[5,220,400],[0,0.5,1],[0,115.30999755859375,0,0,0,0,1,1,1,1]],[26,"view",512,1,[3],[[44,0,-11,[1]]],[0,"c1dc9Kk/CRJqaNnBOP4YGDS",1],[5,240,250]],[33,"bar",512,2,[-12],[0,"b1f27kt1ClHyJvwBLxrEfQY",1],[5,10,30],[0,1,0],[-1,0,0,0,0,0,1,1,1,1]],[30,1,0,5,[0]],[84,1,2,6],[85,false,0.75,0.23,null,1,3,7],[49,"item",512,3,[[75,"ScrollView content\n\n",16,20,1,-13,[2]]],[0,"5280bTjVfhISb/ztQTswOuX",1],[4,4278190080],[5,131.33,65.2],[0,0,1],[-102.19999694824219,-10.149999618530273,0,0,0,0,1,1,1,1]]],0,[0,1,1,0,0,1,0,-2,8,0,-1,2,0,-2,4,0,-1,7,0,0,2,0,0,2,0,-1,5,0,-1,9,0,0,4,0,-1,6,0,0,9,0,2,1,3,14,4,7,18,8,13],[0,0,0,0,0,0,0,6],[-1,-1,-1,-1,3,-1,3,3],[0,0,0,0,26,0,4,25]],[[[10,".bin",[[11,1089,[12,34848],[[1,"a_normal",5126,3],[1,"a_position",5126,3],[1,"a_uv0",5126,2]]]],[[14,[0],[13,34848,12288]]],[1,-0.5,-0.5,-0.5],[1,0.5,0.5,0.5]],-1],0,0,[],[],[]],[[[2,"plane"],[7,"plane",true,[[4,-2,[0],1]],[0,"9fhEbTXI1IApxjLqbjx+1L",-1]]],0,[0,1,1,0,0,1,0,2,1,2],[0,0],[-1,4],[1,13]],[[{"name":"default-particle","rect":[2,2,61,61],"offset":[0.5,-0.5],"originalSize":[64,64],"capInsets":[0,0,0,0]}],[1],0,[0],[5],[98]],[[[20,"__builtin-editor-gizmo-line",[{"hash":2579669062,"record":null,"name":"__builtin-editor-gizmo-line|gizmo-line-vs|gizmo-line-fs:front","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nattribute vec3 a_position;\nvoid main () {\n  gl_Position = cc_matViewProj * cc_matWorld * vec4(a_position, 1);\n  gl_Position.z -= 0.0001;\n}","frag":"\nprecision highp float;\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\nuniform DIFFUSE_COLOR {\n  vec4 diffuseColor;\n};\nvec4 front() {\n  return CCFragOutput(diffuseColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nvoid main () {\n  gl_Position = cc_matViewProj * cc_matWorld * vec4(a_position, 1);\n  gl_Position.z -= 0.0001;\n}","frag":"\nprecision highp float;\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\nuniform vec4 diffuseColor;\nvec4 front() {\n  return CCFragOutput(diffuseColor);\n}\nvoid main() { gl_FragColor = front(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"OUTPUT_TO_GAMMA","type":"boolean","defines":[]}],"blocks":[{"name":"DIFFUSE_COLOR","binding":0,"members":[{"name":"diffuseColor","type":16,"count":1}],"defines":[]}],"samplers":[]},{"hash":2538316070,"record":null,"name":"__builtin-editor-gizmo-line|gizmo-line-vs|gizmo-line-fs:back","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nattribute vec3 a_position;\nvoid main () {\n  gl_Position = cc_matViewProj * cc_matWorld * vec4(a_position, 1);\n  gl_Position.z -= 0.0001;\n}","frag":"\nprecision highp float;\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\nuniform DIFFUSE_COLOR {\n  vec4 diffuseColor;\n};\nvec4 back() {\n  return CCFragOutput(vec4(diffuseColor.rgb, diffuseColor.a * 0.2));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nvoid main () {\n  gl_Position = cc_matViewProj * cc_matWorld * vec4(a_position, 1);\n  gl_Position.z -= 0.0001;\n}","frag":"\nprecision highp float;\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\nuniform vec4 diffuseColor;\nvec4 back() {\n  return CCFragOutput(vec4(diffuseColor.rgb, diffuseColor.a * 0.2));\n}\nvoid main() { gl_FragColor = back(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"OUTPUT_TO_GAMMA","type":"boolean","defines":[]}],"blocks":[{"name":"DIFFUSE_COLOR","binding":0,"members":[{"name":"diffuseColor","type":16,"count":1}],"defines":[]}],"samplers":[]}],[{"passes":[{"stage":"transparent","program":"__builtin-editor-gizmo-line|gizmo-line-vs|gizmo-line-fs:front","blendState":{"targets":[{"blend":true,"blendEq":32774,"blendSrc":770,"blendDst":1}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":true},"properties":{"diffuseColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}}}},{"stage":"transparent","program":"__builtin-editor-gizmo-line|gizmo-line-vs|gizmo-line-fs:back","blendState":{"targets":[{"blend":true,"blendEq":32774,"blendSrc":770,"blendDst":1}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":true,"depthFunc":516},"properties":{"diffuseColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}}}}]}]]],0,0,[],[],[]],[[[3,"richtext",1],[16,"richText",[[86,50,-2]],[0,"fd4fe1WoCpJK6rVCZ13Z14R",-1],[5,153.38,50],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[[3,"progressBar",1],[15,"progressBar",[-5],[[5,1,0,-2,[1],2],[87,300,0.5,-4,-3]],[0,"c8bd6EVT6lD4bVMS1d/i0BC",-1],[5,300,15]],[33,"bar",512,1,[-6],[0,"38d28QPqAdC1L4aQLAAwhV2",1],[5,150,15],[0,0,0.5],[-150,0,0,0,0,0,1,1,1,1]],[30,1,0,2,[0]]],0,[0,1,1,0,0,1,0,19,3,0,0,1,0,-1,2,0,-1,3,0,2,1,6],[0,0,0,3],[-1,-1,3,3],[0,0,23,22]],[[[2,"ambient"],[19,"light",true,[[36,3,0.25,1,1000,50,-2]],[0,"33zOkteexCqamZ4PXuwJaW",-1],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[[3,"editbox",1],[15,"editbox",[-6,-7,-8],[[88,8,6,-5,-4,-3,-2]],[0,"590f66n7/1CY5uRJYcGGuJO",-1],[5,160,40]],[32,"BACKGROUND_SPRITE",512,1,[[-9,[41,0,45,160,40,-10]],1,4],[0,"fcoT9mL35BlLUlR0xQ5QBI",1],[5,160,40]],[59,"TEXT_LABEL",512,false,1,[[-11,[42,0,45,2,158,40,-12]],1,4],[0,"0blsIXU11M95uloDvhs/X9",1],[5,158,40],[0,0,1],[-78,20,0,0,0,0,1,1,1,1]],[60,"PLACEHOLDER_LABEL",512,1,[[-13,[42,0,45,2,158,40,-14]],1,4],[0,"d9Sjcz6gxMGYCoLbO/scJL",1],[4,4290493371],[5,158,40],[0,0,1],[-78,20,0,0,0,0,1,1,1,1]],[30,1,0,2,[0]],[76,20,25,false,1,1,3],[77,"Enter text here...",20,25,false,1,1,4,[1]]],0,[0,1,1,0,20,5,0,21,7,0,22,6,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,-1,5,0,0,2,0,-1,6,0,0,3,0,-1,7,0,0,4,0,2,1,14],[0,0,5],[-1,-1,3],[0,0,21]],[[{"name":"default_progressbar","rect":[0,0,30,15],"offset":[0,0],"originalSize":[30,15],"capInsets":[10,4,10,4]}],[1],0,[0],[5],[99]],[[{"name":"default_toggle_normal","rect":[0,0,28,28],"offset":[0,0],"originalSize":[28,28],"capInsets":[0,0,0,0]}],[1],0,[0],[5],[100]],[[[20,"__builtin-editor-gizmo-unlit",[{"hash":304964736,"record":null,"name":"__builtin-editor-gizmo-unlit|gizmo-unlit-vs|gizmo-unlit-fs:front","glsl3":{"vert":"\nprecision highp float;\nattribute vec3 a_position;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nvoid main () {\n  gl_Position = cc_matViewProj * cc_matWorld * vec4(a_position, 1);\n}","frag":"\nprecision highp float;\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\nuniform DIFFUSE_COLOR {\n  vec4 diffuseColor;\n};\nvec4 front() {\n  return CCFragOutput(diffuseColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"},"glsl1":{"vert":"\nprecision highp float;\nattribute vec3 a_position;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nvoid main () {\n  gl_Position = cc_matViewProj * cc_matWorld * vec4(a_position, 1);\n}","frag":"\nprecision highp float;\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\nuniform vec4 diffuseColor;\nvec4 front() {\n  return CCFragOutput(diffuseColor);\n}\nvoid main() { gl_FragColor = front(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"OUTPUT_TO_GAMMA","type":"boolean","defines":[]}],"blocks":[{"name":"DIFFUSE_COLOR","binding":0,"members":[{"name":"diffuseColor","type":16,"count":1}],"defines":[]}],"samplers":[]}],[{"passes":[{"stage":"transparent","program":"__builtin-editor-gizmo-unlit|gizmo-unlit-vs|gizmo-unlit-fs:front","blendState":{"targets":[{"blend":true,"blendEq":32774}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"diffuseColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}}}}]}]]],0,0,[],[],[]],[[[2,"quad"],[7,"quad",true,[[4,-2,[0],1]],[0,"9b58ZeS0JLyLtsBZ/OlhCu",-1]]],0,[0,1,1,0,0,1,0,2,1,2],[0,0],[-1,4],[1,14]],[[[2,"3d-particle"],[7,"ParticleSystem3D",true,[[89,-2,[0],[21],[25,5],[90],[25,1],[25,5],[21],[21],[25,10],[21],[91,true,0,[21]]]],[0,"a7grHQWGBCppuqJqizdE84",-1]]],0,[0,1,1,0,0,1,0,2,1,2],[0],[-1],[31]],[[[2,"3d-camera"],[19,"3D Camera",true,[[43,1024,false,false,-2]],[0,"abdJ5/jGlPzq+iDQghzEti",-1],[0,0,10,0,0,0,1,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[{"name":"default_toggle_disabled","rect":[0,0,28,28],"offset":[0,0],"originalSize":[28,28],"capInsets":[0,0,0,0]}],[1],0,[0],[5],[101]],[[[3,"layout",1],[16,"layout",[[67,1,0,-2,0],[92,-3,[5,200,150]]],[0,"7f8d2O3hcNDT55RjJXZrQyg",-1],[5,200,150],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,0,1,0,2,1,3],[0],[3],[4]],[[[10,".bin",[[11,129,[12,4128],[[1,"a_normal",5126,3],[1,"a_position",5126,3],[1,"a_uv0",5126,2]]]],[[14,[0],[13,4128,384]]],[1,-0.5,-0.5,-0.499999940395355],[1,0.5,0.5,0.5]],-1],0,0,[],[],[]],[[{"name":"default_toggle_pressed","rect":[0,0,28,28],"offset":[0,0],"originalSize":[28,28],"capInsets":[0,0,0,0]}],[1],0,[0],[5],[102]],[[[3,"tiledmap",1],[22,"New TiledMap",[[94,-2]],[0,"6d9cbIJlHhJ/4JAwDJiN9SB",-1],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[[10,".bin",[[11,1155,[12,36960],[[1,"a_normal",5126,3],[1,"a_position",5126,3],[1,"a_uv0",5126,2]]]],[[14,[0],[13,36960,12288]]],[1,-0.5,-1,-0.5],[1,0.5,1,0.5]],-1],0,0,[],[],[]],[[{"name":"default_progressbar_bg","rect":[0,0,60,15],"offset":[0,0],"originalSize":[60,15],"capInsets":[10,4,10,4]}],[1],0,[0],[5],[103]],[[[2,"2d-camera"],[22,"2D Camera",[[83,0.1,-2]],[0,"abdJ5/jGlPzq+iDQghzEti",-1],[0,0,554.2562584220408,0,0,0,1,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[[3,"webview",1],[16,"webview",[[95,-2]],[0,"2fb356PwclC8L2CbHhqGUVr",-1],[5,300,200],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[{"name":"default_sprite","rect":[0,2,40,36],"offset":[0,0],"originalSize":[40,40],"capInsets":[0,0,0,0]}],[1],0,[0],[5],[104]],[[{"name":"default_toggle_checkmark","rect":[4,5,20,18],"offset":[0,0],"originalSize":[28,28],"capInsets":[0,0,0,0]}],[1],0,[0],[5],[105]],[[[96,"primitives",[{"name":"RootNode","path":"","scale":[1,1,1],"children":[1,2,3,4,5,6,7,8],"position":[0,0,0],"quat":[0,0,0,1]},{"name":"capsule","mesh":0,"parent":null,"path":"capsule","scale":[100,100,100],"position":[0,0,0],"quat":[8.14603353660459e-8,0,0,1]},{"name":"plane","mesh":1,"parent":null,"path":"plane","scale":[100,100,100],"position":[0,0,0],"quat":[8.14603353660459e-8,0,0,1]},{"name":"cone","mesh":2,"parent":null,"path":"cone","scale":[100,100,100],"position":[0,0,0],"quat":[-0.707106828689575,0,0,0.707106709480286]},{"name":"torus","mesh":3,"parent":null,"path":"torus","scale":[100,100,100],"position":[0,0,0],"quat":[8.14603353660459e-8,0,0,1]},{"name":"sphere","mesh":4,"parent":null,"path":"sphere","scale":[100,100,100],"position":[0,0,0],"quat":[8.14603353660459e-8,0,0,1]},{"name":"quad","mesh":5,"parent":null,"path":"quad","scale":[100,100,100],"position":[0,0,0],"quat":[8.14603353660459e-8,0,0,1]},{"name":"cylinder","mesh":6,"parent":null,"path":"cylinder","scale":[100,100,100],"position":[0,0,0],"quat":[8.14603353660459e-8,0,0,1]},{"name":"box","mesh":7,"parent":null,"path":"box","scale":[100,100,100],"position":[0,0,0],"quat":[8.14603353660459e-8,0,0,1]}]]],0,0,[],[],[]],[[[3,"sprite",1],[16,"Sprite",[[68,-2,0]],[0,"d7118yAG5lKybkFOAh8koPL",-1],[5,40,36],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[0],[3],[27]],[[[3,"button",1],[15,"button",[-4],[[70,2,-3,[4,4293322470],[4,4291348680],[4,3363338360],-2,3,4,5,6]],[0,"59d3ePxgxhP17q/bKZe2Mkj",-1],[5,100,40]],[26,"Background",512,1,[-7],[[5,1,0,-5,[1],2],[41,0,45,100,40,-6]],[0,"abgf9KGgdMsahHlBHOj/Jv",1],[5,100,40]],[50,"Label",512,2,[[78,"button",20,false,1,1,1,1,-8,[0]]],[0,"89ZOGI9GxIA7ukuWhMzutw",1],[4,4278190080],[5,100,40]]],0,[0,1,1,0,7,2,0,0,1,0,-1,2,0,0,2,0,0,2,0,-1,3,0,0,3,0,2,1,8],[0,0,0,0,0,0,0],[-1,-1,3,10,11,12,13],[0,0,6,6,20,6,8]],[[[10,".bin",[[11,121,[12,3872],[[1,"a_normal",5126,3],[1,"a_position",5126,3],[1,"a_uv0",5126,2]]]],[[14,[0],[13,3872,1200]]],[1,-5,0,-5],[1,5,0,5]],-1],0,0,[],[],[]],[[{"name":"default_sprite_splash","rect":[0,0,2,2],"offset":[0,0],"originalSize":[2,2],"capInsets":[0,0,0,0]}],[1],0,[0],[5],[106]],[[[97,"buffer",".bin"],-1],0,0,[],[],[]],[[[98,[{},"0",11,[{"defines":{}},"props",11,[{},"diffuseColor",8,[4,4286545791]]]]]],0,0,[0],[15],[10]],[[[2,"box"],[7,"box",true,[[4,-2,[0],1]],[0,"04A14e1BZJxrPk6zgr35H5",-1]]],0,[0,1,1,0,0,1,0,2,1,2],[0,0],[-1,4],[1,7]],[[[2,"primitives"],[31,"RootNode",true,[-2,-3,-4,-5,-6,-7,-8,-9],[64,-1,24]],[8,"capsule",true,1,[[4,-10,[0],1]],[9,"capsule",1,2],[0,0,0,8.146033536604618e-8,0,0,0.9999999999999967,100,100,100],[1,0.000009334666828389458,0,0]],[8,"plane",true,1,[[4,-11,[3],4]],[9,"plane",1,5],[0,0,0,8.146033536604618e-8,0,0,0.9999999999999967,100,100,100],[1,0.000009334666828389458,0,0]],[8,"cone",true,1,[[4,-12,[6],7]],[9,"cone",1,8],[0,0,0,-0.7071068286895765,0,0,0.7071067336835153,100,100,100],[1,-90.00000769819565,0,0]],[8,"torus",true,1,[[4,-13,[9],10]],[9,"torus",1,11],[0,0,0,8.146033536604618e-8,0,0,0.9999999999999967,100,100,100],[1,0.000009334666828389458,0,0]],[8,"sphere",true,1,[[4,-14,[12],13]],[9,"sphere",1,14],[0,0,0,8.146033536604618e-8,0,0,0.9999999999999967,100,100,100],[1,0.000009334666828389458,0,0]],[8,"quad",true,1,[[4,-15,[15],16]],[9,"quad",1,17],[0,0,0,8.146033536604618e-8,0,0,0.9999999999999967,100,100,100],[1,0.000009334666828389458,0,0]],[8,"cylinder",true,1,[[4,-16,[18],19]],[9,"cylinder",1,20],[0,0,0,8.146033536604618e-8,0,0,0.9999999999999967,100,100,100],[1,0.000009334666828389458,0,0]],[8,"box",true,1,[[4,-17,[21],22]],[9,"box",1,23],[0,0,0,8.146033536604618e-8,0,0,0.9999999999999967,100,100,100],[1,0.000009334666828389458,0,0]]],0,[0,1,1,0,-1,2,0,-2,3,0,-3,4,0,-4,5,0,-5,6,0,-6,7,0,-7,8,0,-8,9,0,0,2,0,0,3,0,0,4,0,0,5,0,0,6,0,0,7,0,0,8,0,0,9,0,2,1,17],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,4,6,-1,4,6,-1,4,6,-1,4,6,-1,4,6,-1,4,6,-1,4,6,-1,4,6,6],[1,11,3,1,13,3,1,12,3,1,16,3,1,15,3,1,14,3,1,9,3,1,7,3,3]],[[[20,"builtin-phong",[{"hash":3560892936,"record":null,"name":"builtin-phong|phong-vs|phong-fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n#if CC_USE_SKINNING\n  in vec4 a_weights;\n  in vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform SKINNING {\n      vec2 jointsTextureSize;\n    };\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform JOINT_MATRIX {\n      mat4 jointMatrices[50];\n    };\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nin vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nin vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nin vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nin vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nin vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\nvoid CCVertInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n    #if CC_USE_ATTRIBUTE_TANGENT\n      In.tangent = m * In.tangent;\n    #endif\n  #endif\n}\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform CC_SHADOW {\n    mat4 cc_shadow_lightViewProjMatrix[2];\n    vec4 cc_shadow_info[2];\n  };\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\nvoid CCShadowInput (vec3 worldPos) {\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  for (int i = 0; i < CC_NUM_SHADOW_LIGHTS; i++) {\n    v_posLightSpace[i] = cc_shadow_lightViewProjMatrix[i] * vec4(worldPos, 1.0);\n    v_depth[i] = (v_posLightSpace[i].z + cc_shadow_info[i].x) / (cc_shadow_info[i].x + cc_shadow_info[i].y);\n  }\n  #endif\n}\nuniform MAIN_TILING {\n  vec2 mainTiling;\n  vec2 mainOffset;\n};\n#if CC_USE_ATTRIBUTE_UV0 && (USE_DIFFUSE_TEXTURE || USE_EMISSIVE_TEXTURE || USE_SPECULAR_TEXTURE || USE_NORMAL_TEXTURE)\n  out mediump vec2 v_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\n  out lowp vec4 v_color;\n#endif\n#if USE_NORMAL_TEXTURE\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\nout vec3 v_worldNormal;\nout vec3 v_worldPos;\nout vec3 v_viewDirection;\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  vec4 position = In.position;\n  v_worldNormal = normalize((cc_matWorldIT * vec4(In.normal, 0)).xyz);\n  v_worldPos = (cc_matWorld * position).xyz;\n  v_viewDirection = normalize(cc_cameraPos.xyz - v_worldPos);\n  #if CC_USE_ATTRIBUTE_UV0 && (USE_DIFFUSE_TEXTURE || USE_EMISSIVE_TEXTURE || USE_SPECULAR_TEXTURE || USE_NORMAL_TEXTURE)\n    v_uv0 = In.uv * mainTiling + mainOffset;\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    v_color = In.color;\n  #endif\n  #if USE_NORMAL_TEXTURE\n    v_tangent = normalize((cc_matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_worldNormal, v_tangent) * In.tangent.w;\n  #endif\n  CCShadowInput(v_worldPos);\n  gl_Position = cc_matViewProj * cc_matWorld * position;\n}","frag":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform PhongFrag {\n  lowp vec4 diffuseColor;\n  lowp vec4 specularColor;\n  lowp vec4 emissiveColor;\n  float glossiness;\n};\n#if USE_DIFFUSE_TEXTURE\n  uniform sampler2D diffuseTexture;\n#endif\n#if USE_SPECULAR && USE_SPECULAR_TEXTURE\n  uniform sampler2D specularTexture;\n#endif\n#if USE_EMISSIVE && USE_EMISSIVE_TEXTURE\n  uniform sampler2D emissiveTexture;\n#endif\n#if USE_NORMAL_TEXTURE\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalTexture;\n#endif\nin vec3 v_worldNormal;\nin vec3 v_worldPos;\nin vec3 v_viewDirection;\n#if CC_USE_ATTRIBUTE_UV0 && (USE_DIFFUSE_TEXTURE || (USE_EMISSIVE && USE_EMISSIVE_TEXTURE) || (USE_SPECULAR && USE_SPECULAR_TEXTURE) || USE_NORMAL_TEXTURE)\n  in mediump vec2 v_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform CC_SHADOW {\n    mat4 cc_shadow_lightViewProjMatrix[2];\n    vec4 cc_shadow_info[2];\n  };\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\nfloat getDepth(sampler2D shadowMap, vec2 shadowUV) {\n    return unpackRGBAToDepth(texture(shadowMap, shadowUV));\n}\nfloat computeFallOff(float shadow, vec2 coords, float frustumEdgeFalloff) {\n  return shadow;\n}\nfloat shadowSimple(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness) {\n  float closestDepth = getDepth(shadowMap, shadowUV);\n  return currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n}\nfloat shadowPCF3X3(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness, float shadowSize) {\n  float shadow = 0.0;\n  for (int x = -1; x <= 1; ++x) {\n    for (int y = -1; y <= 1; ++y) {\n      float closestDepth = getDepth(shadowMap, shadowUV + vec2(x, y) * 1.0/shadowSize);\n      shadow += currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n    }\n  }\n  shadow /= 9.0;\n  return shadow;\n}\nfloat shadowPCF5X5(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness, float shadowSize) {\n  float shadow = 0.0;\n  for (int x = -2; x <= 2; ++x) {\n    for (int y = -2; y <= 2; ++y) {\n      float closestDepth = getDepth(shadowMap, shadowUV + vec2(x, y) * 1.0/shadowSize);\n      shadow += currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n    }\n  }\n  shadow /= 25.0;\n  return shadow;\n}\n#if CC_NUM_LIGHTS > 0\nuniform CCLIGHTS {\n  vec4 cc_lightPositionAndRange[4];\n  vec4 cc_lightDirection[4];\n  vec4 cc_lightColor[4];\n};\n#endif\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n  vec4 lightColor;\n};\nLightInfo computeDirectionalLighting(\n  vec4 lightDirection,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  ret.lightDir = -normalize(lightDirection.xyz);\n  ret.radiance = lightColor.rgb;\n  ret.lightColor = lightColor;\n  return ret;\n}\nLightInfo computePointLighting(\n  vec3 worldPosition,\n  vec4 lightPositionAndRange,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPositionAndRange.xyz - worldPosition;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightPositionAndRange.w);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor.rgb * attenuation;\n  ret.lightColor = lightColor;\n  return ret;\n}\nLightInfo computeSpotLighting(\n  vec3 worldPosition,\n  vec4 lightPositionAndRange,\n  vec4 lightDirection,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPositionAndRange.xyz - worldPosition;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightPositionAndRange.w);\n  lightDir = normalize(lightDir);\n  float cosConeAngle = max(0., dot(lightDirection.xyz, -lightDir));\n  cosConeAngle = cosConeAngle < lightDirection.w ? 0. : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle, lightColor.w);\n  ret.lightDir = lightDir;\n  ret.radiance = lightColor.rgb * attenuation * cosConeAngle;\n  ret.lightColor = lightColor;\n  return ret;\n}\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nstruct PhongSurface {\n  vec3 diffuse;\n  vec3 emissive;\n  vec3 specular;\n  float opacity;\n  float glossiness;\n  vec3 position;\n  vec3 normal;\n  vec3 viewDirection;\n};\nLighting brdf (PhongSurface s, LightInfo info) {\n  Lighting result;\n  float ndh = 0.0;\n  vec3 halfDir = normalize(s.viewDirection + info.lightDir);\n  float NdotH = max(0.0, dot(s.normal, halfDir));\n  NdotH = pow(NdotH, max(1.0, s.glossiness * 128.0));\n  result.diffuse = info.radiance * max(0.0, dot(s.normal, info.lightDir));\n  result.specular = info.radiance * NdotH;\n  return result;\n}\nvec4 composePhongShading (Lighting lighting, PhongSurface s) {\n  vec4 o = vec4(0.0, 0.0, 0.0, 1.0);\n  o.rgb = lighting.diffuse * s.diffuse;\n  #if USE_EMISSIVE\n    o.rgb += s.emissive;\n  #endif\n  #if USE_SPECULAR\n    o.rgb += lighting.specular * s.specular;\n  #endif\n  o.a = s.opacity;\n  return o;\n}\nvec3 ambient(PhongSurface s, vec4 ambientColor) {\n  return s.diffuse * ambientColor.rgb;\n}\nvec4 CCPhongShading (in PhongSurface s) {\n  Lighting result;\n  result.diffuse = vec3(0, 0, 0);\n  result.specular = vec3(0, 0, 0);\n  #if CC_NUM_LIGHTS > 0\n    #if CC_LIGHT_0_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[0]);\n    #else\n      LightInfo info0;\n      #if CC_LIGHT_0_TYPE == 0\n        info0 = computeDirectionalLighting(cc_lightDirection[0], cc_lightColor[0]);\n      #elif CC_LIGHT_0_TYPE == 1\n        info0 = computePointLighting(s.position, cc_lightPositionAndRange[0], cc_lightColor[0]);\n      #elif CC_LIGHT_0_TYPE == 2\n        info0 = computeSpotLighting(s.position, cc_lightPositionAndRange[0], cc_lightDirection[0], cc_lightColor[0]);\n      #endif\n      Lighting result0 = brdf(s, info0);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n    float shadow_0 = 1.0;\n    vec2 projCoords0 = v_posLightSpace[0].xy / v_posLightSpace[0].w;\n    vec2 shadowUV0 = projCoords0 * 0.5 + vec2(0.5);\n    if (shadowUV0.x >= 0.0 && shadowUV0.x <= 1.0 && shadowUV0.y >= 0.0 && shadowUV0.y <= 1.0) {\n      float currentDepth0 = clamp(v_depth[0], 0.0, 1.0);\n      #if CC_SHADOW_0_TYPE == 3\n        shadow_0 = shadowPCF3X3(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w, cc_shadow_info[0].z);\n      #elif CC_SHADOW_0_TYPE == 4\n        shadow_0 = shadowPCF5X5(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w, cc_shadow_info[0].z);\n      #else\n        shadow_0 = shadowSimple(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w);\n      #endif\n      shadow_0 = computeFallOff(shadow_0, projCoords0, 0.0);\n    }\n    result0.diffuse *= shadow_0;\n    result0.specular *= shadow_0;\n  #endif\n      result.diffuse += result0.diffuse;\n      result.specular += result0.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 1\n    #if CC_LIGHT_1_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[1]);\n    #else\n      LightInfo info1;\n      #if CC_LIGHT_1_TYPE == 0\n        info1 = computeDirectionalLighting(cc_lightDirection[1], cc_lightColor[1]);\n      #elif CC_LIGHT_1_TYPE == 1\n        info1 = computePointLighting(s.position, cc_lightPositionAndRange[1], cc_lightColor[1]);\n      #elif CC_LIGHT_1_TYPE == 2\n        info1 = computeSpotLighting(s.position, cc_lightPositionAndRange[1], cc_lightDirection[1], cc_lightColor[1]);\n      #endif\n      Lighting result1 = brdf(s, info1);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 1\n    float shadow_1 = 1.0;\n    vec2 projCoords1 = v_posLightSpace[1].xy / v_posLightSpace[1].w;\n    vec2 shadowUV1 = projCoords1 * 0.5 + vec2(0.5);\n    if (shadowUV1.x >= 0.0 && shadowUV1.x <= 1.0 && shadowUV1.y >= 0.0 && shadowUV1.y <= 1.0) {\n      float currentDepth1 = clamp(v_depth[1], 0.0, 1.0);\n      #if CC_SHADOW_1_TYPE == 3\n        shadow_1 = shadowPCF3X3(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w, cc_shadow_info[1].z);\n      #elif CC_SHADOW_1_TYPE == 4\n        shadow_1 = shadowPCF5X5(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w, cc_shadow_info[1].z);\n      #else\n        shadow_1 = shadowSimple(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w);\n      #endif\n      shadow_1 = computeFallOff(shadow_1, projCoords1, 0.0);\n    }\n    result1.diffuse *= shadow_1;\n    result1.specular *= shadow_1;\n  #endif\n      result.diffuse += result1.diffuse;\n      result.specular += result1.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 2\n    #if CC_LIGHT_2_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[2]);\n    #else\n      LightInfo info2;\n      #if CC_LIGHT_2_TYPE == 0\n        info2 = computeDirectionalLighting(cc_lightDirection[2], cc_lightColor[2]);\n      #elif CC_LIGHT_2_TYPE == 1\n        info2 = computePointLighting(s.position, cc_lightPositionAndRange[2], cc_lightColor[2]);\n      #elif CC_LIGHT_2_TYPE == 2\n        info2 = computeSpotLighting(s.position, cc_lightPositionAndRange[2], cc_lightDirection[2], cc_lightColor[2]);\n      #endif\n      Lighting result2 = brdf(s, info2);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 2\n    float shadow_2 = 1.0;\n    vec2 projCoords2 = v_posLightSpace[2].xy / v_posLightSpace[2].w;\n    vec2 shadowUV2 = projCoords2 * 0.5 + vec2(0.5);\n    if (shadowUV2.x >= 0.0 && shadowUV2.x <= 1.0 && shadowUV2.y >= 0.0 && shadowUV2.y <= 1.0) {\n      float currentDepth2 = clamp(v_depth[2], 0.0, 1.0);\n      #if CC_SHADOW_2_TYPE == 3\n        shadow_2 = shadowPCF3X3(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w, cc_shadow_info[2].z);\n      #elif CC_SHADOW_2_TYPE == 4\n        shadow_2 = shadowPCF5X5(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w, cc_shadow_info[2].z);\n      #else\n        shadow_2 = shadowSimple(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w);\n      #endif\n      shadow_2 = computeFallOff(shadow_2, projCoords2, 0.0);\n    }\n    result2.diffuse *= shadow_2;\n    result2.specular *= shadow_2;\n  #endif\n      result.diffuse += result2.diffuse;\n      result.specular += result2.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 3\n    #if CC_LIGHT_3_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[3]);\n    #else\n      LightInfo info3;\n      #if CC_LIGHT_3_TYPE == 0\n        info3 = computeDirectionalLighting(cc_lightDirection[3], cc_lightColor[3]);\n      #elif CC_LIGHT_3_TYPE == 1\n        info3 = computePointLighting(s.position, cc_lightPositionAndRange[3], cc_lightColor[3]);\n      #elif CC_LIGHT_3_TYPE == 2\n        info3 = computeSpotLighting(s.position, cc_lightPositionAndRange[3], cc_lightDirection[3], cc_lightColor[3]);\n      #endif\n      Lighting result3 = brdf(s, info3);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 3\n    float shadow_3 = 1.0;\n    vec2 projCoords3 = v_posLightSpace[3].xy / v_posLightSpace[3].w;\n    vec2 shadowUV3 = projCoords3 * 0.5 + vec2(0.5);\n    if (shadowUV3.x >= 0.0 && shadowUV3.x <= 1.0 && shadowUV3.y >= 0.0 && shadowUV3.y <= 1.0) {\n      float currentDepth3 = clamp(v_depth[3], 0.0, 1.0);\n      #if CC_SHADOW_3_TYPE == 3\n        shadow_3 = shadowPCF3X3(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w, cc_shadow_info[3].z);\n      #elif CC_SHADOW_3_TYPE == 4\n        shadow_3 = shadowPCF5X5(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w, cc_shadow_info[3].z);\n      #else\n        shadow_3 = shadowSimple(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w);\n      #endif\n      shadow_3 = computeFallOff(shadow_3, projCoords3, 0.0);\n    }\n    result3.diffuse *= shadow_3;\n    result3.specular *= shadow_3;\n  #endif\n      result.diffuse += result3.diffuse;\n      result.specular += result3.specular;\n    #endif\n  #endif\n  return composePhongShading(result, s);\n}\nvoid surf (out PhongSurface s) {\n  vec4 diffuse = vec4(1, 1, 1, 1);\n  #if CC_USE_ATTRIBUTE_COLOR\n    diffuse *= v_color;\n  #endif\n  diffuse *= diffuseColor;\n  #if USE_DIFFUSE_TEXTURE\n  vec4 diffuseTexture_tmp = texture(diffuseTexture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_diffuseTexture\n      diffuseTexture_tmp.a *= texture(diffuseTexture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    diffuse.rgb *= (diffuseTexture_tmp.rgb * diffuseTexture_tmp.rgb);\n    diffuse.a *= diffuseTexture_tmp.a;\n  #else\n    diffuse *= diffuseTexture_tmp;\n  #endif\n  #endif\n  ALPHA_TEST(diffuse);\n  s.diffuse = diffuse.rgb;\n  s.opacity = diffuse.a;\n  #if USE_EMISSIVE\n    s.emissive = emissiveColor.rgb;\n    #if USE_EMISSIVE_TEXTURE\n  vec4 emissiveTexture_tmp = texture(emissiveTexture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_emissiveTexture\n      emissiveTexture_tmp.a *= texture(emissiveTexture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    s.emissive.rgb *= (emissiveTexture_tmp.rgb * emissiveTexture_tmp.rgb);\n  #else\n    s.emissive.rgb *= emissiveTexture_tmp.rgb;\n  #endif\n    #endif\n  #endif\n  #if USE_SPECULAR\n    s.specular = specularColor.rgb;\n    #if USE_SPECULAR_TEXTURE\n  vec4 specularTexture_tmp = texture(specularTexture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_specularTexture\n      specularTexture_tmp.a *= texture(specularTexture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    s.specular.rgb *= (specularTexture_tmp.rgb * specularTexture_tmp.rgb);\n  #else\n    s.specular.rgb *= specularTexture_tmp.rgb;\n  #endif\n    #endif\n  #endif\n  s.normal = v_worldNormal;\n  #if USE_NORMAL_TEXTURE\n    vec3 nmmp = texture(normalTexture, v_uv0).xyz - vec3(0.5);\n    s.normal =\n      nmmp.x * normalize(v_tangent) +\n      nmmp.y * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n    s.normal = normalize(s.normal);\n  #endif\n  s.position = v_worldPos;\n  s.viewDirection = v_viewDirection;\n  s.glossiness = glossiness;\n}\nvoid main () {\n  PhongSurface s;\n  surf(s);\n  vec4 color = CCPhongShading(s);\n  gl_FragColor = CCFragOutput(color);\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\n#if CC_USE_SKINNING\n  attribute vec4 a_weights;\n  attribute vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform vec2 jointsTextureSize;\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture2D(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture2D(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture2D(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture2D(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture2D(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform mat4 jointMatrices[50];\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nattribute vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nattribute vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nattribute vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nattribute vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nattribute vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\nvoid CCVertInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n    #if CC_USE_ATTRIBUTE_TANGENT\n      In.tangent = m * In.tangent;\n    #endif\n  #endif\n}\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform mat4 cc_shadow_lightViewProjMatrix[2];\nuniform vec4 cc_shadow_info[2];\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\nvoid CCShadowInput (vec3 worldPos) {\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  for (int i = 0; i < CC_NUM_SHADOW_LIGHTS; i++) {\n    v_posLightSpace[i] = cc_shadow_lightViewProjMatrix[i] * vec4(worldPos, 1.0);\n    v_depth[i] = (v_posLightSpace[i].z + cc_shadow_info[i].x) / (cc_shadow_info[i].x + cc_shadow_info[i].y);\n  }\n  #endif\n}\nuniform vec2 mainTiling;\nuniform vec2 mainOffset;\n#if CC_USE_ATTRIBUTE_UV0 && (USE_DIFFUSE_TEXTURE || USE_EMISSIVE_TEXTURE || USE_SPECULAR_TEXTURE || USE_NORMAL_TEXTURE)\n  varying mediump vec2 v_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if USE_NORMAL_TEXTURE\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nvarying vec3 v_worldNormal;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewDirection;\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  vec4 position = In.position;\n  v_worldNormal = normalize((cc_matWorldIT * vec4(In.normal, 0)).xyz);\n  v_worldPos = (cc_matWorld * position).xyz;\n  v_viewDirection = normalize(cc_cameraPos.xyz - v_worldPos);\n  #if CC_USE_ATTRIBUTE_UV0 && (USE_DIFFUSE_TEXTURE || USE_EMISSIVE_TEXTURE || USE_SPECULAR_TEXTURE || USE_NORMAL_TEXTURE)\n    v_uv0 = In.uv * mainTiling + mainOffset;\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    v_color = In.color;\n  #endif\n  #if USE_NORMAL_TEXTURE\n    v_tangent = normalize((cc_matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_worldNormal, v_tangent) * In.tangent.w;\n  #endif\n  CCShadowInput(v_worldPos);\n  gl_Position = cc_matViewProj * cc_matWorld * position;\n}","frag":"\nprecision highp float;\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform lowp vec4 diffuseColor;\nuniform lowp vec4 specularColor;\nuniform lowp vec4 emissiveColor;\nuniform float glossiness;\n#if USE_DIFFUSE_TEXTURE\n  uniform sampler2D diffuseTexture;\n#endif\n#if USE_SPECULAR && USE_SPECULAR_TEXTURE\n  uniform sampler2D specularTexture;\n#endif\n#if USE_EMISSIVE && USE_EMISSIVE_TEXTURE\n  uniform sampler2D emissiveTexture;\n#endif\n#if USE_NORMAL_TEXTURE\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalTexture;\n#endif\nvarying vec3 v_worldNormal;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewDirection;\n#if CC_USE_ATTRIBUTE_UV0 && (USE_DIFFUSE_TEXTURE || (USE_EMISSIVE && USE_EMISSIVE_TEXTURE) || (USE_SPECULAR && USE_SPECULAR_TEXTURE) || USE_NORMAL_TEXTURE)\n  varying mediump vec2 v_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform vec4 cc_shadow_info[2];\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\nfloat getDepth(sampler2D shadowMap, vec2 shadowUV) {\n    return unpackRGBAToDepth(texture2D(shadowMap, shadowUV));\n}\nfloat computeFallOff(float shadow, vec2 coords, float frustumEdgeFalloff) {\n  return shadow;\n}\nfloat shadowSimple(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness) {\n  float closestDepth = getDepth(shadowMap, shadowUV);\n  return currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n}\nfloat shadowPCF3X3(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness, float shadowSize) {\n  float shadow = 0.0;\n  for (int x = -1; x <= 1; ++x) {\n    for (int y = -1; y <= 1; ++y) {\n      float closestDepth = getDepth(shadowMap, shadowUV + vec2(x, y) * 1.0/shadowSize);\n      shadow += currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n    }\n  }\n  shadow /= 9.0;\n  return shadow;\n}\nfloat shadowPCF5X5(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness, float shadowSize) {\n  float shadow = 0.0;\n  for (int x = -2; x <= 2; ++x) {\n    for (int y = -2; y <= 2; ++y) {\n      float closestDepth = getDepth(shadowMap, shadowUV + vec2(x, y) * 1.0/shadowSize);\n      shadow += currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n    }\n  }\n  shadow /= 25.0;\n  return shadow;\n}\n#if CC_NUM_LIGHTS > 0\nuniform vec4 cc_lightPositionAndRange[4];\nuniform vec4 cc_lightDirection[4];\nuniform vec4 cc_lightColor[4];\n#endif\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n  vec4 lightColor;\n};\nLightInfo computeDirectionalLighting(\n  vec4 lightDirection,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  ret.lightDir = -normalize(lightDirection.xyz);\n  ret.radiance = lightColor.rgb;\n  ret.lightColor = lightColor;\n  return ret;\n}\nLightInfo computePointLighting(\n  vec3 worldPosition,\n  vec4 lightPositionAndRange,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPositionAndRange.xyz - worldPosition;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightPositionAndRange.w);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor.rgb * attenuation;\n  ret.lightColor = lightColor;\n  return ret;\n}\nLightInfo computeSpotLighting(\n  vec3 worldPosition,\n  vec4 lightPositionAndRange,\n  vec4 lightDirection,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPositionAndRange.xyz - worldPosition;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightPositionAndRange.w);\n  lightDir = normalize(lightDir);\n  float cosConeAngle = max(0., dot(lightDirection.xyz, -lightDir));\n  cosConeAngle = cosConeAngle < lightDirection.w ? 0. : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle, lightColor.w);\n  ret.lightDir = lightDir;\n  ret.radiance = lightColor.rgb * attenuation * cosConeAngle;\n  ret.lightColor = lightColor;\n  return ret;\n}\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nstruct PhongSurface {\n  vec3 diffuse;\n  vec3 emissive;\n  vec3 specular;\n  float opacity;\n  float glossiness;\n  vec3 position;\n  vec3 normal;\n  vec3 viewDirection;\n};\nLighting brdf (PhongSurface s, LightInfo info) {\n  Lighting result;\n  float ndh = 0.0;\n  vec3 halfDir = normalize(s.viewDirection + info.lightDir);\n  float NdotH = max(0.0, dot(s.normal, halfDir));\n  NdotH = pow(NdotH, max(1.0, s.glossiness * 128.0));\n  result.diffuse = info.radiance * max(0.0, dot(s.normal, info.lightDir));\n  result.specular = info.radiance * NdotH;\n  return result;\n}\nvec4 composePhongShading (Lighting lighting, PhongSurface s) {\n  vec4 o = vec4(0.0, 0.0, 0.0, 1.0);\n  o.rgb = lighting.diffuse * s.diffuse;\n  #if USE_EMISSIVE\n    o.rgb += s.emissive;\n  #endif\n  #if USE_SPECULAR\n    o.rgb += lighting.specular * s.specular;\n  #endif\n  o.a = s.opacity;\n  return o;\n}\nvec3 ambient(PhongSurface s, vec4 ambientColor) {\n  return s.diffuse * ambientColor.rgb;\n}\nvec4 CCPhongShading (in PhongSurface s) {\n  Lighting result;\n  result.diffuse = vec3(0, 0, 0);\n  result.specular = vec3(0, 0, 0);\n  #if CC_NUM_LIGHTS > 0\n    #if CC_LIGHT_0_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[0]);\n    #else\n      LightInfo info0;\n      #if CC_LIGHT_0_TYPE == 0\n        info0 = computeDirectionalLighting(cc_lightDirection[0], cc_lightColor[0]);\n      #elif CC_LIGHT_0_TYPE == 1\n        info0 = computePointLighting(s.position, cc_lightPositionAndRange[0], cc_lightColor[0]);\n      #elif CC_LIGHT_0_TYPE == 2\n        info0 = computeSpotLighting(s.position, cc_lightPositionAndRange[0], cc_lightDirection[0], cc_lightColor[0]);\n      #endif\n      Lighting result0 = brdf(s, info0);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n    float shadow_0 = 1.0;\n    vec2 projCoords0 = v_posLightSpace[0].xy / v_posLightSpace[0].w;\n    vec2 shadowUV0 = projCoords0 * 0.5 + vec2(0.5);\n    if (shadowUV0.x >= 0.0 && shadowUV0.x <= 1.0 && shadowUV0.y >= 0.0 && shadowUV0.y <= 1.0) {\n      float currentDepth0 = clamp(v_depth[0], 0.0, 1.0);\n      #if CC_SHADOW_0_TYPE == 3\n        shadow_0 = shadowPCF3X3(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w, cc_shadow_info[0].z);\n      #elif CC_SHADOW_0_TYPE == 4\n        shadow_0 = shadowPCF5X5(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w, cc_shadow_info[0].z);\n      #else\n        shadow_0 = shadowSimple(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w);\n      #endif\n      shadow_0 = computeFallOff(shadow_0, projCoords0, 0.0);\n    }\n    result0.diffuse *= shadow_0;\n    result0.specular *= shadow_0;\n  #endif\n      result.diffuse += result0.diffuse;\n      result.specular += result0.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 1\n    #if CC_LIGHT_1_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[1]);\n    #else\n      LightInfo info1;\n      #if CC_LIGHT_1_TYPE == 0\n        info1 = computeDirectionalLighting(cc_lightDirection[1], cc_lightColor[1]);\n      #elif CC_LIGHT_1_TYPE == 1\n        info1 = computePointLighting(s.position, cc_lightPositionAndRange[1], cc_lightColor[1]);\n      #elif CC_LIGHT_1_TYPE == 2\n        info1 = computeSpotLighting(s.position, cc_lightPositionAndRange[1], cc_lightDirection[1], cc_lightColor[1]);\n      #endif\n      Lighting result1 = brdf(s, info1);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 1\n    float shadow_1 = 1.0;\n    vec2 projCoords1 = v_posLightSpace[1].xy / v_posLightSpace[1].w;\n    vec2 shadowUV1 = projCoords1 * 0.5 + vec2(0.5);\n    if (shadowUV1.x >= 0.0 && shadowUV1.x <= 1.0 && shadowUV1.y >= 0.0 && shadowUV1.y <= 1.0) {\n      float currentDepth1 = clamp(v_depth[1], 0.0, 1.0);\n      #if CC_SHADOW_1_TYPE == 3\n        shadow_1 = shadowPCF3X3(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w, cc_shadow_info[1].z);\n      #elif CC_SHADOW_1_TYPE == 4\n        shadow_1 = shadowPCF5X5(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w, cc_shadow_info[1].z);\n      #else\n        shadow_1 = shadowSimple(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w);\n      #endif\n      shadow_1 = computeFallOff(shadow_1, projCoords1, 0.0);\n    }\n    result1.diffuse *= shadow_1;\n    result1.specular *= shadow_1;\n  #endif\n      result.diffuse += result1.diffuse;\n      result.specular += result1.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 2\n    #if CC_LIGHT_2_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[2]);\n    #else\n      LightInfo info2;\n      #if CC_LIGHT_2_TYPE == 0\n        info2 = computeDirectionalLighting(cc_lightDirection[2], cc_lightColor[2]);\n      #elif CC_LIGHT_2_TYPE == 1\n        info2 = computePointLighting(s.position, cc_lightPositionAndRange[2], cc_lightColor[2]);\n      #elif CC_LIGHT_2_TYPE == 2\n        info2 = computeSpotLighting(s.position, cc_lightPositionAndRange[2], cc_lightDirection[2], cc_lightColor[2]);\n      #endif\n      Lighting result2 = brdf(s, info2);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 2\n    float shadow_2 = 1.0;\n    vec2 projCoords2 = v_posLightSpace[2].xy / v_posLightSpace[2].w;\n    vec2 shadowUV2 = projCoords2 * 0.5 + vec2(0.5);\n    if (shadowUV2.x >= 0.0 && shadowUV2.x <= 1.0 && shadowUV2.y >= 0.0 && shadowUV2.y <= 1.0) {\n      float currentDepth2 = clamp(v_depth[2], 0.0, 1.0);\n      #if CC_SHADOW_2_TYPE == 3\n        shadow_2 = shadowPCF3X3(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w, cc_shadow_info[2].z);\n      #elif CC_SHADOW_2_TYPE == 4\n        shadow_2 = shadowPCF5X5(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w, cc_shadow_info[2].z);\n      #else\n        shadow_2 = shadowSimple(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w);\n      #endif\n      shadow_2 = computeFallOff(shadow_2, projCoords2, 0.0);\n    }\n    result2.diffuse *= shadow_2;\n    result2.specular *= shadow_2;\n  #endif\n      result.diffuse += result2.diffuse;\n      result.specular += result2.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 3\n    #if CC_LIGHT_3_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[3]);\n    #else\n      LightInfo info3;\n      #if CC_LIGHT_3_TYPE == 0\n        info3 = computeDirectionalLighting(cc_lightDirection[3], cc_lightColor[3]);\n      #elif CC_LIGHT_3_TYPE == 1\n        info3 = computePointLighting(s.position, cc_lightPositionAndRange[3], cc_lightColor[3]);\n      #elif CC_LIGHT_3_TYPE == 2\n        info3 = computeSpotLighting(s.position, cc_lightPositionAndRange[3], cc_lightDirection[3], cc_lightColor[3]);\n      #endif\n      Lighting result3 = brdf(s, info3);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 3\n    float shadow_3 = 1.0;\n    vec2 projCoords3 = v_posLightSpace[3].xy / v_posLightSpace[3].w;\n    vec2 shadowUV3 = projCoords3 * 0.5 + vec2(0.5);\n    if (shadowUV3.x >= 0.0 && shadowUV3.x <= 1.0 && shadowUV3.y >= 0.0 && shadowUV3.y <= 1.0) {\n      float currentDepth3 = clamp(v_depth[3], 0.0, 1.0);\n      #if CC_SHADOW_3_TYPE == 3\n        shadow_3 = shadowPCF3X3(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w, cc_shadow_info[3].z);\n      #elif CC_SHADOW_3_TYPE == 4\n        shadow_3 = shadowPCF5X5(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w, cc_shadow_info[3].z);\n      #else\n        shadow_3 = shadowSimple(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w);\n      #endif\n      shadow_3 = computeFallOff(shadow_3, projCoords3, 0.0);\n    }\n    result3.diffuse *= shadow_3;\n    result3.specular *= shadow_3;\n  #endif\n      result.diffuse += result3.diffuse;\n      result.specular += result3.specular;\n    #endif\n  #endif\n  return composePhongShading(result, s);\n}\nvoid surf (out PhongSurface s) {\n  vec4 diffuse = vec4(1, 1, 1, 1);\n  #if CC_USE_ATTRIBUTE_COLOR\n    diffuse *= v_color;\n  #endif\n  diffuse *= diffuseColor;\n  #if USE_DIFFUSE_TEXTURE\n  vec4 diffuseTexture_tmp = texture2D(diffuseTexture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_diffuseTexture\n      diffuseTexture_tmp.a *= texture2D(diffuseTexture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    diffuse.rgb *= (diffuseTexture_tmp.rgb * diffuseTexture_tmp.rgb);\n    diffuse.a *= diffuseTexture_tmp.a;\n  #else\n    diffuse *= diffuseTexture_tmp;\n  #endif\n  #endif\n  ALPHA_TEST(diffuse);\n  s.diffuse = diffuse.rgb;\n  s.opacity = diffuse.a;\n  #if USE_EMISSIVE\n    s.emissive = emissiveColor.rgb;\n    #if USE_EMISSIVE_TEXTURE\n  vec4 emissiveTexture_tmp = texture2D(emissiveTexture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_emissiveTexture\n      emissiveTexture_tmp.a *= texture2D(emissiveTexture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    s.emissive.rgb *= (emissiveTexture_tmp.rgb * emissiveTexture_tmp.rgb);\n  #else\n    s.emissive.rgb *= emissiveTexture_tmp.rgb;\n  #endif\n    #endif\n  #endif\n  #if USE_SPECULAR\n    s.specular = specularColor.rgb;\n    #if USE_SPECULAR_TEXTURE\n  vec4 specularTexture_tmp = texture2D(specularTexture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_specularTexture\n      specularTexture_tmp.a *= texture2D(specularTexture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    s.specular.rgb *= (specularTexture_tmp.rgb * specularTexture_tmp.rgb);\n  #else\n    s.specular.rgb *= specularTexture_tmp.rgb;\n  #endif\n    #endif\n  #endif\n  s.normal = v_worldNormal;\n  #if USE_NORMAL_TEXTURE\n    vec3 nmmp = texture2D(normalTexture, v_uv0).xyz - vec3(0.5);\n    s.normal =\n      nmmp.x * normalize(v_tangent) +\n      nmmp.y * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n    s.normal = normalize(s.normal);\n  #endif\n  s.position = v_worldPos;\n  s.viewDirection = v_viewDirection;\n  s.glossiness = glossiness;\n}\nvoid main () {\n  PhongSurface s;\n  surf(s);\n  vec4 color = CCPhongShading(s);\n  gl_FragColor = CCFragOutput(color);\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CC_SHADOW","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"CCLIGHTS","defines":["CC_NUM_LIGHTS"]}],"samplers":[{"name":"cc_shadow_map_0","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"cc_shadow_map_1","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]}]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_JOINTS_TEXTRUE","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"CC_JOINTS_TEXTURE_FLOAT32","type":"boolean","defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"CC_USE_ATTRIBUTE_UV0","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_COLOR","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_NORMAL","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_TANGENT","type":"boolean","defines":[]},{"name":"CC_USE_SHADOW_MAP","type":"boolean","defines":[]},{"name":"CC_NUM_SHADOW_LIGHTS","type":"number","defines":["CC_USE_SHADOW_MAP"],"range":[0,3]},{"name":"USE_DIFFUSE_TEXTURE","type":"boolean","defines":[]},{"name":"USE_NORMAL_TEXTURE","type":"boolean","defines":[]},{"name":"OUTPUT_TO_GAMMA","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_SPECULAR","type":"boolean","defines":[]},{"name":"USE_SPECULAR_TEXTURE","type":"boolean","defines":["USE_SPECULAR"]},{"name":"USE_EMISSIVE","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_TEXTURE","type":"boolean","defines":["USE_EMISSIVE"]},{"name":"CC_NUM_LIGHTS","type":"number","defines":[],"range":[0,3]},{"name":"CC_LIGHT_0_TYPE","type":"number","defines":["CC_NUM_LIGHTS"],"range":[0,3]},{"name":"CC_SHADOW_0_TYPE","type":"number","defines":["CC_NUM_LIGHTS","CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"],"range":[0,3]},{"name":"CC_LIGHT_1_TYPE","type":"number","defines":["CC_NUM_LIGHTS"],"range":[0,3]},{"name":"CC_SHADOW_1_TYPE","type":"number","defines":["CC_NUM_LIGHTS","CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"],"range":[0,3]},{"name":"CC_LIGHT_2_TYPE","type":"number","defines":["CC_NUM_LIGHTS"],"range":[0,3]},{"name":"CC_SHADOW_2_TYPE","type":"number","defines":["CC_NUM_LIGHTS","CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"],"range":[0,3]},{"name":"CC_LIGHT_3_TYPE","type":"number","defines":["CC_NUM_LIGHTS"],"range":[0,3]},{"name":"CC_SHADOW_3_TYPE","type":"number","defines":["CC_NUM_LIGHTS","CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"],"range":[0,3]},{"name":"CC_USE_ALPHA_ATLAS_diffuseTexture","type":"boolean","defines":["USE_DIFFUSE_TEXTURE"]},{"name":"INPUT_IS_GAMMA","type":"boolean","defines":["USE_DIFFUSE_TEXTURE"]},{"name":"CC_USE_ALPHA_ATLAS_emissiveTexture","type":"boolean","defines":["USE_EMISSIVE","USE_EMISSIVE_TEXTURE"]},{"name":"CC_USE_ALPHA_ATLAS_specularTexture","type":"boolean","defines":["USE_SPECULAR","USE_SPECULAR_TEXTURE"]}],"blocks":[{"name":"SKINNING","binding":0,"members":[{"name":"jointsTextureSize","type":14,"count":1}],"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"JOINT_MATRIX","binding":1,"members":[{"name":"jointMatrices","type":26,"count":50}],"defines":["CC_USE_SKINNING"]},{"name":"MAIN_TILING","binding":2,"members":[{"name":"mainTiling","type":14,"count":1},{"name":"mainOffset","type":14,"count":1}],"defines":[]},{"name":"ALPHA_TEST","binding":3,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"PhongFrag","binding":4,"members":[{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissiveColor","type":16,"count":1},{"name":"glossiness","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"jointsTexture","type":29,"count":1,"binding":30,"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"diffuseTexture","type":29,"count":1,"binding":31,"defines":["USE_DIFFUSE_TEXTURE"]},{"name":"specularTexture","type":29,"count":1,"binding":32,"defines":["USE_SPECULAR","USE_SPECULAR_TEXTURE"]},{"name":"emissiveTexture","type":29,"count":1,"binding":33,"defines":["USE_EMISSIVE","USE_EMISSIVE_TEXTURE"]},{"name":"normalTexture","type":29,"count":1,"binding":34,"defines":["USE_NORMAL_TEXTURE"]}]},{"hash":1165371292,"record":null,"name":"builtin-phong|shadow-map-vs|shadow-map-fs","glsl3":{"vert":"\nprecision highp float;\nin vec3 a_position;\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nuniform CC_SHADOW_MAP {\n  mat4  cc_shadow_map_lightViewProjMatrix;\n  vec4  cc_shadow_map_info;\n  float cc_shadow_map_bias;\n};\nout float v_depth;\n#if CC_USE_SKINNING\n  in vec4 a_weights;\n  in vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform SKINNING {\n      vec2 jointsTextureSize;\n    };\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform JOINT_MATRIX {\n      mat4 jointMatrices[50];\n    };\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nvoid SKIN_VERTEX(inout vec4 a1) {\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    a1 = m * a1;\n  #endif\n}\nvoid SKIN_VERTEX(inout vec4 a1, inout vec4 a2) {\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    a1 = m * a1;\n    a2 = m * a2;\n  #endif\n}\nvoid SKIN_VERTEX(inout vec4 a1, inout vec4 a2, inout vec4 a3) {\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    a1 = m * a1;\n    a2 = m * a2;\n    a3 = m * a3;\n  #endif\n}\nvoid main () {\n  vec4 position = vec4(a_position, 1);\n  SKIN_VERTEX(position);\n  gl_Position = cc_shadow_map_lightViewProjMatrix * cc_matWorld * position;\n  v_depth = ((gl_Position.z + cc_shadow_map_info.x) / (cc_shadow_map_info.x + cc_shadow_map_info.y)) + cc_shadow_map_bias;\n}","frag":"\nprecision highp float;\nin float v_depth;\nvec4 packDepthToRGBA(float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nvoid main () {\n    gl_FragColor = packDepthToRGBA(v_depth);\n}"},"glsl1":{"vert":"\nprecision highp float;\nattribute vec3 a_position;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_shadow_map_lightViewProjMatrix;\nuniform vec4 cc_shadow_map_info;\nuniform float cc_shadow_map_bias;\nvarying float v_depth;\n#if CC_USE_SKINNING\n  attribute vec4 a_weights;\n  attribute vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform vec2 jointsTextureSize;\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture2D(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture2D(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture2D(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture2D(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture2D(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform mat4 jointMatrices[50];\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nvoid SKIN_VERTEX(inout vec4 a1) {\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    a1 = m * a1;\n  #endif\n}\nvoid SKIN_VERTEX(inout vec4 a1, inout vec4 a2) {\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    a1 = m * a1;\n    a2 = m * a2;\n  #endif\n}\nvoid SKIN_VERTEX(inout vec4 a1, inout vec4 a2, inout vec4 a3) {\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    a1 = m * a1;\n    a2 = m * a2;\n    a3 = m * a3;\n  #endif\n}\nvoid main () {\n  vec4 position = vec4(a_position, 1);\n  SKIN_VERTEX(position);\n  gl_Position = cc_shadow_map_lightViewProjMatrix * cc_matWorld * position;\n  v_depth = ((gl_Position.z + cc_shadow_map_info.x) / (cc_shadow_map_info.x + cc_shadow_map_info.y)) + cc_shadow_map_bias;\n}","frag":"\nprecision highp float;\nvarying float v_depth;\nvec4 packDepthToRGBA(float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nvoid main () {\n    gl_FragColor = packDepthToRGBA(v_depth);\n}"},"builtins":{"globals":{"blocks":[{"name":"CC_SHADOW_MAP","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_JOINTS_TEXTRUE","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"CC_JOINTS_TEXTURE_FLOAT32","type":"boolean","defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]}],"blocks":[{"name":"SKINNING","binding":0,"members":[{"name":"jointsTextureSize","type":14,"count":1}],"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"JOINT_MATRIX","binding":1,"members":[{"name":"jointMatrices","type":26,"count":50}],"defines":["CC_USE_SKINNING"]}],"samplers":[{"name":"jointsTexture","type":29,"count":1,"binding":30,"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]}]}],[{"passes":[{"name":"phong","program":"builtin-phong|phong-vs|phong-fs","rasterizerState":{"cullMode":1029},"depthStencilState":{"depthTest":true,"depthWrite":true},"properties":{"alphaThreshold":{"type":13,"value":[0.5]},"mainTiling":{"type":14,"value":[1,1]},"mainOffset":{"type":14,"value":[0,0]},"diffuseColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"diffuseTexture":{"value":"white","type":29},"specularColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"specularTexture":{"value":"white","type":29},"emissiveColor":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveTexture":{"value":"white","type":29},"glossiness":{"type":13,"value":[10]},"normalTexture":{"value":"white","type":29}}},{"name":"shadowcast","stage":"shadowcast","program":"builtin-phong|shadow-map-vs|shadow-map-fs","rasterizerState":{"cullMode":1029},"depthStencilState":{"depthTest":true,"depthWrite":true}}]}]]],0,0,[],[],[]],[[[10,".bin",[[11,193,[12,6176],[[1,"a_normal",5126,3],[1,"a_position",5126,3],[1,"a_uv0",5126,2]]]],[[14,[0],[13,6176,768]]],[1,-0.5,-1,-0.5],[1,0.5,1,0.5]],-1],0,0,[],[],[]],[[[2,"cone"],[51,"cone",true,[[4,-2,[0],1]],[0,"71bfK5TRVH64FzEUsiCu4S",-1],[0,0,0,-0.7071068286895765,0,0,0.7071067336835153,1,1,1],[1,-90.00000769819565,0,0]]],0,[0,1,1,0,0,1,0,2,1,2],[0,0],[-1,4],[1,12]],[[[100,"atom",".plist"],-1],0,0,[0],[16],[29]],[[{"name":"atom","rect":[0,0,31,31],"offset":[0,0],"originalSize":[31,31],"capInsets":[0,0,0,0]}],[1],0,[0],[5],[107]],[[[3,"toggleContainer",1],[15,"toggleContainer",[-3,-4,-5],[[101,-2]],[0,"8762b/ljEVCT4m/QHu2tS1g",-1],[5,221,61]],[17,"toggle1",1,[-9,-10],[[38,3,-8,[4,4292269782],-7,-6]],[0,"f8ae482OYFF86r5AHHZHzkB",1],[5,41,28],[-62,3,0,0,0,0,1,1,1,1]],[17,"toggle2",1,[-14,-15],[[39,3,false,-13,[4,4292269782],-12,-11]],[0,"4b82d4NuWJDnZcPM+lR6By/",1],[5,42,28],[15,3,0,0,0,0,1,1,1,1]],[17,"toggle3",1,[-19,-20],[[39,3,false,-18,[4,4292269782],-17,-16]],[0,"2b5ebCn5ohKwJt/iEtuj16b",1],[5,37,28],[91,3,0,0,0,0,1,1,1,1]],[6,"Background",512,2,[[18,2,false,-21,[0],1]],[0,"12e439SyJxPm6pHTRj/H92b",1],[5,32,32]],[28,"checkmark",512,2,[-22],[0,"d5f81EvT59O3IYhi0b8awdA",1],[5,32,32]],[29,2,false,6,[2]],[6,"Background",512,3,[[18,2,false,-23,[3],4]],[0,"23182iNXjhGfbiM+k2MoPhG",1],[5,32,32]],[23,"checkmark",512,false,3,[-24],[0,"67160qO3xZPvYfuiiHVaiyt",1],[5,32,32]],[24,2,false,9],[6,"Background",512,4,[[18,2,false,-25,[5],6]],[0,"7042dNy6Q1OmYWrdrd+O8Q7",1],[5,32,32]],[23,"checkmark",512,false,4,[-26],[0,"faafbv5RyVCB5deTlAulXVo",1],[5,32,32]],[24,2,false,12]],0,[0,1,1,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,8,7,0,7,2,0,0,2,0,-1,5,0,-2,6,0,8,10,0,7,3,0,0,3,0,-1,8,0,-2,9,0,8,13,0,7,4,0,0,4,0,-1,11,0,-2,12,0,0,5,0,-1,7,0,0,8,0,-1,10,0,0,11,0,-1,13,0,2,1,26],[0,0,0,0,0,0,0,7,10,13],[-1,3,-1,-1,3,-1,3,3,3,3],[0,2,0,0,2,0,2,5,5,5]],[[[99,"builtin-phong",{"0":{"defines":{"USE_SPECULAR":true}}}]],0,0,[0],[15],[10]],[[{"name":"default_scrollbar_bg","rect":[0,0,30,15],"offset":[0,0],"originalSize":[30,15],"capInsets":[10,4,10,4]}],[1],0,[0],[5],[108]],[[[3,"pageview",1],[34,"pageview",[-3,-4,-5],[-2],[0,"52f01L6ceBGDrJGf8m2N/2X",-1],[5,400,350]],[52,"content",512,[-7,-8,-9],[[93,1,1,15,-6,[5,1200,350]]],[0,"47588+/BXNHEK1F1sC9uHbf",1],[5,1200,350],[0,0,0.5],[-200,0,0,0,0,0,1,1,1,1]],[26,"view",512,1,[2],[[44,0,-10,[8]]],[0,"5b1864GVRZEC7Qc8fzYUge7",1],[5,400,350]],[6,"background",512,1,[[5,1,0,-11,[0],1]],[0,"d4995IHzA9DsKLlMTyCB0bq",1],[5,400,350]],[27,"page_1",512,2,[[5,1,0,-12,[2],3]],[0,"e4b25otxWBLVpmoEY72dW1B",1],[4,4291348735],[5,400,290],[200,0,0,0,0,0,1,1,1,1]],[27,"page_2",512,2,[[5,1,0,-13,[4],5]],[0,"0460dpbuuVL6IrBc9SGei8F",1],[4,4291362760],[5,400,290],[600,0,0,0,0,0,1,1,1,1]],[27,"page_3",512,2,[[5,1,0,-14,[6],7]],[0,"7a1b8sccmBN1Jj/ZHKaE3JK",1],[4,4294953160],[5,400,290],[1000,0,0,0,0,0,1,1,1,1]],[61,"indicator",512,1,[-15],[0,"c3bcdZElclEBJbaV6uqwUJx",1],[5,100,27],[0,-160,0,0,0,0,1,1,1,1]],[102,10,8,[5,10,10]],[103,0.5,1,2,9]],0,[0,1,1,0,-1,10,0,-1,4,0,-2,3,0,-3,8,0,0,2,0,-1,5,0,-2,6,0,-3,7,0,0,3,0,0,4,0,0,5,0,0,6,0,0,7,0,-1,9,0,2,1,2,14,3,9,23,10,15],[0,0,0,0,0,0,0,0,0,9],[-1,3,-1,3,-1,3,-1,3,-1,16],[0,4,0,4,0,4,0,4,0,24]],[[[3,"particlesystem",1],[22,"ParticleSystem",[[104,-2,[4,4294967295],[4,4278190080],[4,16777215],[4,0],0]],[0,"868c9k4nqZNHpGMlTm0Yx6q",-1],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[0],[24],[30]],[[[3,"toggleGroup",1],[34,"toggleGroup",[-3,-4,-5],[-2],[0,"d7d5Rc1ntDm421UemL1Qj0",-1],[5,221,61]],[17,"toggle1",1,[-10,-11],[[71,3,-9,[4,4292269782],-8,-7,-6]],[0,"25DeyD94tFkalmK6Tg7UdE",1],[5,41,28],[-62,3,0,0,0,0,1,1,1,1]],[17,"toggle2",1,[-16,-17],[[40,3,false,-15,[4,4292269782],-14,-13,-12]],[0,"61w1JEqOlGsaSeDBTtJqu3",1],[5,42,28],[15,3,0,0,0,0,1,1,1,1]],[17,"toggle3",1,[-22,-23],[[40,3,false,-21,[4,4292269782],-20,-19,-18]],[0,"99UOOvWWtLsock+J9rw0jb",1],[5,37,28],[91,3,0,0,0,0,1,1,1,1]],[105,1],[6,"Background",512,2,[[18,2,false,-24,[0],1]],[0,"77Nw/VkxBDlYn1tJHSiW69",1],[5,32,32]],[28,"checkmark",512,2,[-25],[0,"eabUMeFj1JHYgwbMpSg1zc",1],[5,32,32]],[29,2,false,7,[2]],[6,"Background",512,3,[[18,2,false,-26,[3],4]],[0,"72QEruyX5CrIAFmVn9a3F6",1],[5,32,32]],[23,"checkmark",512,false,3,[-27],[0,"c7L6vaJVRBDZfq/ZftHdp1",1],[5,32,32]],[24,2,false,10],[6,"Background",512,4,[[18,2,false,-28,[5],6]],[0,"9dSgcVxjxAToRrdMlwhWpR",1],[5,32,32]],[23,"checkmark",512,false,4,[-29],[0,"24Fq6PF85FxZmTxjsAlpwl",1],[5,32,32]],[24,2,false,13]],0,[0,1,1,0,-1,5,0,-1,2,0,-2,3,0,-3,4,0,8,8,0,9,5,0,7,2,0,0,2,0,-1,6,0,-2,7,0,8,11,0,9,5,0,7,3,0,0,3,0,-1,9,0,-2,10,0,8,14,0,9,5,0,7,4,0,0,4,0,-1,12,0,-2,13,0,0,6,0,-1,8,0,0,9,0,-1,11,0,0,12,0,-1,14,0,2,1,29],[0,0,0,0,0,0,0,8,11,14],[-1,3,-1,-1,3,-1,3,3,3,3],[0,2,0,0,2,0,2,5,5,5]],[[[2,"directional"],[19,"light",true,[[37,1000,50,-2]],[0,"33zOkteexCqamZ4PXuwJaW",-1],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[[2,"torus"],[7,"torus",true,[[4,-2,[0],1]],[0,"a1gx3/CoNJb6xz1joaf6oM",-1]]],0,[0,1,1,0,0,1,0,2,1,2],[0,0],[-1,4],[1,16]],[[[20,"builtin-toon",[{"hash":2752667346,"record":null,"name":"builtin-toon|outline-vs:vert|outline-fs:frag","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n#if CC_USE_SKINNING\n  in vec4 a_weights;\n  in vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform SKINNING {\n      vec2 jointsTextureSize;\n    };\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform JOINT_MATRIX {\n      mat4 jointMatrices[50];\n    };\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nin vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nin vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nin vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nin vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nin vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\nvoid CCVertInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n    #if CC_USE_ATTRIBUTE_TANGENT\n      In.tangent = m * In.tangent;\n    #endif\n  #endif\n}\nout vec2 v_uv;\nuniform OutlineVert {\n  float lineWidth;\n  float depthBias;\n};\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  float width = lineWidth * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matViewProj * cc_matWorld * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matViewProj * cc_matWorld * In.position;\n  #endif\n  pos.z -= depthBias * 0.002;\n  v_uv = In.uv;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform CC_SHADOW {\n    mat4 cc_shadow_lightViewProjMatrix[2];\n    vec4 cc_shadow_info[2];\n  };\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\n#if CC_NUM_LIGHTS > 0\nuniform CCLIGHTS {\n  vec4 cc_lightPositionAndRange[4];\n  vec4 cc_lightDirection[4];\n  vec4 cc_lightColor[4];\n};\n#endif\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n  vec4 lightColor;\n};\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nin vec2 v_uv;\nuniform OutlineFrag {\n  vec4 outlineBaseColor;\n};\n#if USE_OUTLINE_BASE_COLOR_MAP\n  uniform sampler2D outlineBaseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = outlineBaseColor;\n  #if CC_NUM_DIR_LIGHTS > 0\n  for (int i = 0; i < CC_NUM_DIR_LIGHTS; i++) {\n      color *= cc_dirLightColor[i];\n  }\n  #endif\n  #if USE_OUTLINE_BASE_COLOR_MAP\n  vec4 outlineBaseColorMap_tmp = texture(outlineBaseColorMap, v_uv);\n  #if CC_USE_ALPHA_ATLAS_outlineBaseColorMap\n      outlineBaseColorMap_tmp.a *= texture(outlineBaseColorMap, v_uv + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    color.rgb *= (outlineBaseColorMap_tmp.rgb * outlineBaseColorMap_tmp.rgb);\n    color.a *= outlineBaseColorMap_tmp.a;\n  #else\n    color *= outlineBaseColorMap_tmp;\n  #endif\n  #endif\n  return vec4(color.rgb, 1.0);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\n#if CC_USE_SKINNING\n  attribute vec4 a_weights;\n  attribute vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform vec2 jointsTextureSize;\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture2D(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture2D(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture2D(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture2D(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture2D(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform mat4 jointMatrices[50];\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nattribute vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nattribute vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nattribute vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nattribute vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nattribute vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\nvoid CCVertInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n    #if CC_USE_ATTRIBUTE_TANGENT\n      In.tangent = m * In.tangent;\n    #endif\n  #endif\n}\nvarying vec2 v_uv;\nuniform float lineWidth;\nuniform float depthBias;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  float width = lineWidth * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matViewProj * cc_matWorld * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matViewProj * cc_matWorld * In.position;\n  #endif\n  pos.z -= depthBias * 0.002;\n  v_uv = In.uv;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\n#if CC_NUM_LIGHTS > 0\n#endif\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n  vec4 lightColor;\n};\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nvarying vec2 v_uv;\nuniform vec4 outlineBaseColor;\n#if USE_OUTLINE_BASE_COLOR_MAP\n  uniform sampler2D outlineBaseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = outlineBaseColor;\n  #if CC_NUM_DIR_LIGHTS > 0\n  for (int i = 0; i < CC_NUM_DIR_LIGHTS; i++) {\n      color *= cc_dirLightColor[i];\n  }\n  #endif\n  #if USE_OUTLINE_BASE_COLOR_MAP\n  vec4 outlineBaseColorMap_tmp = texture2D(outlineBaseColorMap, v_uv);\n  #if CC_USE_ALPHA_ATLAS_outlineBaseColorMap\n      outlineBaseColorMap_tmp.a *= texture2D(outlineBaseColorMap, v_uv + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    color.rgb *= (outlineBaseColorMap_tmp.rgb * outlineBaseColorMap_tmp.rgb);\n    color.a *= outlineBaseColorMap_tmp.a;\n  #else\n    color *= outlineBaseColorMap_tmp;\n  #endif\n  #endif\n  return vec4(color.rgb, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CC_SHADOW","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"CCLIGHTS","defines":["CC_NUM_LIGHTS"]}],"samplers":[{"name":"cc_shadow_map_0","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"cc_shadow_map_1","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]}]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_JOINTS_TEXTRUE","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"CC_JOINTS_TEXTURE_FLOAT32","type":"boolean","defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"CC_USE_ATTRIBUTE_UV0","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_COLOR","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_NORMAL","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_TANGENT","type":"boolean","defines":[]},{"name":"USE_POSITION_SCALING","type":"boolean","defines":[]},{"name":"CC_USE_SHADOW_MAP","type":"boolean","defines":[]},{"name":"CC_NUM_SHADOW_LIGHTS","type":"number","defines":["CC_USE_SHADOW_MAP"],"range":[0,3]},{"name":"CC_NUM_LIGHTS","type":"number","defines":[],"range":[0,3]},{"name":"USE_OUTLINE_BASE_COLOR_MAP","type":"boolean","defines":[]},{"name":"CC_NUM_DIR_LIGHTS","type":"number","defines":[],"range":[0,3]},{"name":"CC_USE_ALPHA_ATLAS_outlineBaseColorMap","type":"boolean","defines":["USE_OUTLINE_BASE_COLOR_MAP"]},{"name":"INPUT_IS_GAMMA","type":"boolean","defines":["USE_OUTLINE_BASE_COLOR_MAP"]}],"blocks":[{"name":"SKINNING","binding":0,"members":[{"name":"jointsTextureSize","type":14,"count":1}],"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"JOINT_MATRIX","binding":1,"members":[{"name":"jointMatrices","type":26,"count":50}],"defines":["CC_USE_SKINNING"]},{"name":"OutlineVert","binding":2,"members":[{"name":"lineWidth","type":13,"count":1},{"name":"depthBias","type":13,"count":1}],"defines":[]},{"name":"OutlineFrag","binding":3,"members":[{"name":"outlineBaseColor","type":16,"count":1}],"defines":[]}],"samplers":[{"name":"jointsTexture","type":29,"count":1,"binding":30,"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"outlineBaseColorMap","type":29,"count":1,"binding":31,"defines":["USE_OUTLINE_BASE_COLOR_MAP"]}]},{"hash":1621866752,"record":null,"name":"builtin-toon|toon-vs:vert|toon-fs:frag","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n#if CC_USE_SKINNING\n  in vec4 a_weights;\n  in vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform SKINNING {\n      vec2 jointsTextureSize;\n    };\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform JOINT_MATRIX {\n      mat4 jointMatrices[50];\n    };\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nin vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nin vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nin vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nin vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nin vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\nvoid CCVertInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n    #if CC_USE_ATTRIBUTE_TANGENT\n      In.tangent = m * In.tangent;\n    #endif\n  #endif\n}\nout vec3 v_position;\nout vec2 v_uv;\nout vec3 v_normal;\nout vec3 v_viewDirection;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\nuniform ToonVert {\n  vec4 tilingOffset;\n};\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  vec4 pos = cc_matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = In.uv * tilingOffset.xy + tilingOffset.zw;\n  v_viewDirection = normalize(cc_cameraPos.xyz - v_position);\n  v_normal = (cc_matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((cc_matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  return cc_matViewProj * pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform CC_SHADOW {\n    mat4 cc_shadow_lightViewProjMatrix[2];\n    vec4 cc_shadow_info[2];\n  };\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\nfloat getDepth(sampler2D shadowMap, vec2 shadowUV) {\n    return unpackRGBAToDepth(texture(shadowMap, shadowUV));\n}\nfloat computeFallOff(float shadow, vec2 coords, float frustumEdgeFalloff) {\n  return shadow;\n}\nfloat shadowSimple(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness) {\n  float closestDepth = getDepth(shadowMap, shadowUV);\n  return currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n}\nfloat shadowPCF3X3(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness, float shadowSize) {\n  float shadow = 0.0;\n  for (int x = -1; x <= 1; ++x) {\n    for (int y = -1; y <= 1; ++y) {\n      float closestDepth = getDepth(shadowMap, shadowUV + vec2(x, y) * 1.0/shadowSize);\n      shadow += currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n    }\n  }\n  shadow /= 9.0;\n  return shadow;\n}\nfloat shadowPCF5X5(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness, float shadowSize) {\n  float shadow = 0.0;\n  for (int x = -2; x <= 2; ++x) {\n    for (int y = -2; y <= 2; ++y) {\n      float closestDepth = getDepth(shadowMap, shadowUV + vec2(x, y) * 1.0/shadowSize);\n      shadow += currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n    }\n  }\n  shadow /= 25.0;\n  return shadow;\n}\n#if CC_NUM_LIGHTS > 0\nuniform CCLIGHTS {\n  vec4 cc_lightPositionAndRange[4];\n  vec4 cc_lightDirection[4];\n  vec4 cc_lightColor[4];\n};\n#endif\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n  vec4 lightColor;\n};\nLightInfo computeDirectionalLighting(\n  vec4 lightDirection,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  ret.lightDir = -normalize(lightDirection.xyz);\n  ret.radiance = lightColor.rgb;\n  ret.lightColor = lightColor;\n  return ret;\n}\nLightInfo computePointLighting(\n  vec3 worldPosition,\n  vec4 lightPositionAndRange,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPositionAndRange.xyz - worldPosition;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightPositionAndRange.w);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor.rgb * attenuation;\n  ret.lightColor = lightColor;\n  return ret;\n}\nLightInfo computeSpotLighting(\n  vec3 worldPosition,\n  vec4 lightPositionAndRange,\n  vec4 lightDirection,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPositionAndRange.xyz - worldPosition;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightPositionAndRange.w);\n  lightDir = normalize(lightDir);\n  float cosConeAngle = max(0., dot(lightDirection.xyz, -lightDir));\n  cosConeAngle = cosConeAngle < lightDirection.w ? 0. : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle, lightColor.w);\n  ret.lightDir = lightDir;\n  ret.radiance = lightColor.rgb * attenuation * cosConeAngle;\n  ret.lightColor = lightColor;\n  return ret;\n}\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nstruct ToonSurface {\n  vec4 baseColor;\n  vec3 specular;\n  float specularThreshold;\n  vec3 position;\n  vec3 normal;\n  vec3 viewDirection;\n  vec3 emissive;\n  vec3 shadowColor;\n  float shadowIntensity;\n  vec3 highlightColor;\n  float lightThreshold;\n  float lightSmoothness;\n};\nconst float T_H = 0.25;\nfloat TreshHoldLighting(float lThreshold, float smoothness, float v) {\n  return smoothstep(lThreshold-smoothness*T_H, lThreshold+smoothness*T_H, v);\n}\nLighting toon (ToonSurface s, LightInfo info) {\n  Lighting result;\n  vec3 N = s.normal;\n  vec3 L = info.lightDir;\n  vec3 V = s.viewDirection;\n  vec3 H = normalize(L + V);\n  float NL = 0.5 * dot(N, L) + 0.5;\n  float NH = 0.5 * dot(H, N) + 0.5;\n  vec3 c = vec3(0.0);\n  vec3 attenuation = info.radiance;\n  vec3 lightColor = info.lightColor.rgb;\n  vec3 shadowColor = mix(s.highlightColor * lightColor, s.shadowColor, s.shadowIntensity);\n  vec3 diffuse = TreshHoldLighting(s.lightThreshold, s.lightSmoothness, NL) * attenuation;\n  diffuse = mix(shadowColor, s.highlightColor * lightColor, diffuse);\n  result.diffuse = diffuse * s.baseColor.rgb;\n  float specularWeight = 1.0 - pow(s.specularThreshold, 5.0);\n  float specularMask = step(specularWeight, NH);\n  vec3 specular = s.specular.rgb * specularMask;\n  result.specular = specular * attenuation;\n  return result;\n}\nvec3 ambient(ToonSurface s, vec4 ambientColor) {\n  return s.baseColor.rgb * ambientColor.rgb;\n}\nvec4 CCToonShading (ToonSurface s) {\n  Lighting result;\n  result.diffuse = vec3(0, 0, 0);\n  result.specular = vec3(0, 0, 0);\n  #if CC_NUM_LIGHTS > 0\n    #if CC_LIGHT_0_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[0]);\n    #else\n      LightInfo info0;\n      #if CC_LIGHT_0_TYPE == 0\n        info0 = computeDirectionalLighting(cc_lightDirection[0], cc_lightColor[0]);\n      #elif CC_LIGHT_0_TYPE == 1\n        info0 = computePointLighting(s.position, cc_lightPositionAndRange[0], cc_lightColor[0]);\n      #elif CC_LIGHT_0_TYPE == 2\n        info0 = computeSpotLighting(s.position, cc_lightPositionAndRange[0], cc_lightDirection[0], cc_lightColor[0]);\n      #endif\n      Lighting result0 = toon(s, info0);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n    float shadow_0 = 1.0;\n    vec2 projCoords0 = v_posLightSpace[0].xy / v_posLightSpace[0].w;\n    vec2 shadowUV0 = projCoords0 * 0.5 + vec2(0.5);\n    if (shadowUV0.x >= 0.0 && shadowUV0.x <= 1.0 && shadowUV0.y >= 0.0 && shadowUV0.y <= 1.0) {\n      float currentDepth0 = clamp(v_depth[0], 0.0, 1.0);\n      #if CC_SHADOW_0_TYPE == 3\n        shadow_0 = shadowPCF3X3(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w, cc_shadow_info[0].z);\n      #elif CC_SHADOW_0_TYPE == 4\n        shadow_0 = shadowPCF5X5(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w, cc_shadow_info[0].z);\n      #else\n        shadow_0 = shadowSimple(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w);\n      #endif\n      shadow_0 = computeFallOff(shadow_0, projCoords0, 0.0);\n    }\n    result0.diffuse *= shadow_0;\n    result0.specular *= shadow_0;\n  #endif\n      result.diffuse += result0.diffuse;\n      result.specular += result0.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 1\n    #if CC_LIGHT_1_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[1]);\n    #else\n      LightInfo info1;\n      #if CC_LIGHT_1_TYPE == 0\n        info1 = computeDirectionalLighting(cc_lightDirection[1], cc_lightColor[1]);\n      #elif CC_LIGHT_1_TYPE == 1\n        info1 = computePointLighting(s.position, cc_lightPositionAndRange[1], cc_lightColor[1]);\n      #elif CC_LIGHT_1_TYPE == 2\n        info1 = computeSpotLighting(s.position, cc_lightPositionAndRange[1], cc_lightDirection[1], cc_lightColor[1]);\n      #endif\n      Lighting result1 = toon(s, info1);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 1\n    float shadow_1 = 1.0;\n    vec2 projCoords1 = v_posLightSpace[1].xy / v_posLightSpace[1].w;\n    vec2 shadowUV1 = projCoords1 * 0.5 + vec2(0.5);\n    if (shadowUV1.x >= 0.0 && shadowUV1.x <= 1.0 && shadowUV1.y >= 0.0 && shadowUV1.y <= 1.0) {\n      float currentDepth1 = clamp(v_depth[1], 0.0, 1.0);\n      #if CC_SHADOW_1_TYPE == 3\n        shadow_1 = shadowPCF3X3(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w, cc_shadow_info[1].z);\n      #elif CC_SHADOW_1_TYPE == 4\n        shadow_1 = shadowPCF5X5(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w, cc_shadow_info[1].z);\n      #else\n        shadow_1 = shadowSimple(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w);\n      #endif\n      shadow_1 = computeFallOff(shadow_1, projCoords1, 0.0);\n    }\n    result1.diffuse *= shadow_1;\n    result1.specular *= shadow_1;\n  #endif\n      result.diffuse += result1.diffuse;\n      result.specular += result1.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 2\n    #if CC_LIGHT_2_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[2]);\n    #else\n      LightInfo info2;\n      #if CC_LIGHT_2_TYPE == 0\n        info2 = computeDirectionalLighting(cc_lightDirection[2], cc_lightColor[2]);\n      #elif CC_LIGHT_2_TYPE == 1\n        info2 = computePointLighting(s.position, cc_lightPositionAndRange[2], cc_lightColor[2]);\n      #elif CC_LIGHT_2_TYPE == 2\n        info2 = computeSpotLighting(s.position, cc_lightPositionAndRange[2], cc_lightDirection[2], cc_lightColor[2]);\n      #endif\n      Lighting result2 = toon(s, info2);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 2\n    float shadow_2 = 1.0;\n    vec2 projCoords2 = v_posLightSpace[2].xy / v_posLightSpace[2].w;\n    vec2 shadowUV2 = projCoords2 * 0.5 + vec2(0.5);\n    if (shadowUV2.x >= 0.0 && shadowUV2.x <= 1.0 && shadowUV2.y >= 0.0 && shadowUV2.y <= 1.0) {\n      float currentDepth2 = clamp(v_depth[2], 0.0, 1.0);\n      #if CC_SHADOW_2_TYPE == 3\n        shadow_2 = shadowPCF3X3(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w, cc_shadow_info[2].z);\n      #elif CC_SHADOW_2_TYPE == 4\n        shadow_2 = shadowPCF5X5(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w, cc_shadow_info[2].z);\n      #else\n        shadow_2 = shadowSimple(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w);\n      #endif\n      shadow_2 = computeFallOff(shadow_2, projCoords2, 0.0);\n    }\n    result2.diffuse *= shadow_2;\n    result2.specular *= shadow_2;\n  #endif\n      result.diffuse += result2.diffuse;\n      result.specular += result2.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 3\n    #if CC_LIGHT_3_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[3]);\n    #else\n      LightInfo info3;\n      #if CC_LIGHT_3_TYPE == 0\n        info3 = computeDirectionalLighting(cc_lightDirection[3], cc_lightColor[3]);\n      #elif CC_LIGHT_3_TYPE == 1\n        info3 = computePointLighting(s.position, cc_lightPositionAndRange[3], cc_lightColor[3]);\n      #elif CC_LIGHT_3_TYPE == 2\n        info3 = computeSpotLighting(s.position, cc_lightPositionAndRange[3], cc_lightDirection[3], cc_lightColor[3]);\n      #endif\n      Lighting result3 = toon(s, info3);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 3\n    float shadow_3 = 1.0;\n    vec2 projCoords3 = v_posLightSpace[3].xy / v_posLightSpace[3].w;\n    vec2 shadowUV3 = projCoords3 * 0.5 + vec2(0.5);\n    if (shadowUV3.x >= 0.0 && shadowUV3.x <= 1.0 && shadowUV3.y >= 0.0 && shadowUV3.y <= 1.0) {\n      float currentDepth3 = clamp(v_depth[3], 0.0, 1.0);\n      #if CC_SHADOW_3_TYPE == 3\n        shadow_3 = shadowPCF3X3(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w, cc_shadow_info[3].z);\n      #elif CC_SHADOW_3_TYPE == 4\n        shadow_3 = shadowPCF5X5(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w, cc_shadow_info[3].z);\n      #else\n        shadow_3 = shadowSimple(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w);\n      #endif\n      shadow_3 = computeFallOff(shadow_3, projCoords3, 0.0);\n    }\n    result3.diffuse *= shadow_3;\n    result3.specular *= shadow_3;\n  #endif\n      result.diffuse += result3.diffuse;\n      result.specular += result3.specular;\n    #endif\n  #endif\n  vec3 finalColor = result.diffuse + result.specular + s.emissive;\n  return vec4(finalColor, s.baseColor.a);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\nin vec3 v_position;\nin vec2 v_uv;\nin vec3 v_viewDirection;\nin vec3 v_normal;\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\nuniform ToonFrag {\n  vec4 colorScale;\n  vec4 specular;\n  vec4 emissive;\n  vec4 shadowColor;\n  vec4 highlightColor;\n  float specularThreshold;\n  float shadowIntensity;\n  float lightThreshold;\n  float lightSmoothness;\n};\nvoid surf (out ToonSurface s) {\n  #if USE_BASE_COLOR_MAP\n    s.baseColor = vec4(1.);\n  vec4 baseColorMap_tmp = texture(baseColorMap, v_uv);\n  #if CC_USE_ALPHA_ATLAS_baseColorMap\n      baseColorMap_tmp.a *= texture(baseColorMap, v_uv + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    s.baseColor.rgb *= (baseColorMap_tmp.rgb * baseColorMap_tmp.rgb);\n    s.baseColor.a *= baseColorMap_tmp.a;\n  #else\n    s.baseColor *= baseColorMap_tmp;\n  #endif\n  #else\n    s.baseColor = highlightColor;\n  #endif\n  s.normal = normalize(v_normal);\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal = normalize(\n      nmmp.x * normalize(v_tangent) +\n      nmmp.y * normalize(v_bitangent) +\n      nmmp.z * s.normal);\n  #endif\n  s.position = v_position;\n  s.specular = specular.rgb * specular.a;\n  #if USE_SPECULAR_MAP\n  vec4 specularMap_tmp = texture(specularMap, v_uv);\n  #if CC_USE_ALPHA_ATLAS_specularMap\n      specularMap_tmp.a *= texture(specularMap, v_uv + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    s.specular.rgb *= (specularMap_tmp.rgb * specularMap_tmp.rgb);\n  #else\n    s.specular.rgb *= specularMap_tmp.rgb;\n  #endif\n  #endif\n  s.emissive = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n  vec4 emissiveMap_tmp = texture(emissiveMap, v_uv);\n  #if CC_USE_ALPHA_ATLAS_emissiveMap\n      emissiveMap_tmp.a *= texture(emissiveMap, v_uv + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    s.emissive.rgb *= (emissiveMap_tmp.rgb * emissiveMap_tmp.rgb);\n  #else\n    s.emissive.rgb *= emissiveMap_tmp.rgb;\n  #endif\n  #endif\n  s.lightThreshold = lightThreshold;\n  s.lightSmoothness = lightSmoothness;\n  s.shadowColor = shadowColor.rgb;\n  s.highlightColor = highlightColor.rgb;\n  s.shadowIntensity = shadowIntensity;\n  s.specularThreshold = specularThreshold;\n  s.viewDirection = v_viewDirection;\n}\nvec4 frag () {\n  ToonSurface s;\n  surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\n#if CC_USE_SKINNING\n  attribute vec4 a_weights;\n  attribute vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform vec2 jointsTextureSize;\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture2D(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture2D(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture2D(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture2D(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture2D(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform mat4 jointMatrices[50];\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nattribute vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nattribute vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nattribute vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nattribute vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nattribute vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\nvoid CCVertInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n    #if CC_USE_ATTRIBUTE_TANGENT\n      In.tangent = m * In.tangent;\n    #endif\n  #endif\n}\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec3 v_normal;\nvarying vec3 v_viewDirection;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nuniform vec4 tilingOffset;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  vec4 pos = cc_matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = In.uv * tilingOffset.xy + tilingOffset.zw;\n  v_viewDirection = normalize(cc_cameraPos.xyz - v_position);\n  v_normal = (cc_matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((cc_matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  return cc_matViewProj * pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform vec4 cc_shadow_info[2];\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\nfloat getDepth(sampler2D shadowMap, vec2 shadowUV) {\n    return unpackRGBAToDepth(texture2D(shadowMap, shadowUV));\n}\nfloat computeFallOff(float shadow, vec2 coords, float frustumEdgeFalloff) {\n  return shadow;\n}\nfloat shadowSimple(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness) {\n  float closestDepth = getDepth(shadowMap, shadowUV);\n  return currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n}\nfloat shadowPCF3X3(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness, float shadowSize) {\n  float shadow = 0.0;\n  for (int x = -1; x <= 1; ++x) {\n    for (int y = -1; y <= 1; ++y) {\n      float closestDepth = getDepth(shadowMap, shadowUV + vec2(x, y) * 1.0/shadowSize);\n      shadow += currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n    }\n  }\n  shadow /= 9.0;\n  return shadow;\n}\nfloat shadowPCF5X5(sampler2D shadowMap, vec2 shadowUV, float currentDepth, float darkness, float shadowSize) {\n  float shadow = 0.0;\n  for (int x = -2; x <= 2; ++x) {\n    for (int y = -2; y <= 2; ++y) {\n      float closestDepth = getDepth(shadowMap, shadowUV + vec2(x, y) * 1.0/shadowSize);\n      shadow += currentDepth > closestDepth  ? 1.0 - darkness : 1.0;\n    }\n  }\n  shadow /= 25.0;\n  return shadow;\n}\n#if CC_NUM_LIGHTS > 0\nuniform vec4 cc_lightPositionAndRange[4];\nuniform vec4 cc_lightDirection[4];\nuniform vec4 cc_lightColor[4];\n#endif\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n  vec4 lightColor;\n};\nLightInfo computeDirectionalLighting(\n  vec4 lightDirection,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  ret.lightDir = -normalize(lightDirection.xyz);\n  ret.radiance = lightColor.rgb;\n  ret.lightColor = lightColor;\n  return ret;\n}\nLightInfo computePointLighting(\n  vec3 worldPosition,\n  vec4 lightPositionAndRange,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPositionAndRange.xyz - worldPosition;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightPositionAndRange.w);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor.rgb * attenuation;\n  ret.lightColor = lightColor;\n  return ret;\n}\nLightInfo computeSpotLighting(\n  vec3 worldPosition,\n  vec4 lightPositionAndRange,\n  vec4 lightDirection,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPositionAndRange.xyz - worldPosition;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightPositionAndRange.w);\n  lightDir = normalize(lightDir);\n  float cosConeAngle = max(0., dot(lightDirection.xyz, -lightDir));\n  cosConeAngle = cosConeAngle < lightDirection.w ? 0. : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle, lightColor.w);\n  ret.lightDir = lightDir;\n  ret.radiance = lightColor.rgb * attenuation * cosConeAngle;\n  ret.lightColor = lightColor;\n  return ret;\n}\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nstruct ToonSurface {\n  vec4 baseColor;\n  vec3 specular;\n  float specularThreshold;\n  vec3 position;\n  vec3 normal;\n  vec3 viewDirection;\n  vec3 emissive;\n  vec3 shadowColor;\n  float shadowIntensity;\n  vec3 highlightColor;\n  float lightThreshold;\n  float lightSmoothness;\n};\nconst float T_H = 0.25;\nfloat TreshHoldLighting(float lThreshold, float smoothness, float v) {\n  return smoothstep(lThreshold-smoothness*T_H, lThreshold+smoothness*T_H, v);\n}\nLighting toon (ToonSurface s, LightInfo info) {\n  Lighting result;\n  vec3 N = s.normal;\n  vec3 L = info.lightDir;\n  vec3 V = s.viewDirection;\n  vec3 H = normalize(L + V);\n  float NL = 0.5 * dot(N, L) + 0.5;\n  float NH = 0.5 * dot(H, N) + 0.5;\n  vec3 c = vec3(0.0);\n  vec3 attenuation = info.radiance;\n  vec3 lightColor = info.lightColor.rgb;\n  vec3 shadowColor = mix(s.highlightColor * lightColor, s.shadowColor, s.shadowIntensity);\n  vec3 diffuse = TreshHoldLighting(s.lightThreshold, s.lightSmoothness, NL) * attenuation;\n  diffuse = mix(shadowColor, s.highlightColor * lightColor, diffuse);\n  result.diffuse = diffuse * s.baseColor.rgb;\n  float specularWeight = 1.0 - pow(s.specularThreshold, 5.0);\n  float specularMask = step(specularWeight, NH);\n  vec3 specular = s.specular.rgb * specularMask;\n  result.specular = specular * attenuation;\n  return result;\n}\nvec3 ambient(ToonSurface s, vec4 ambientColor) {\n  return s.baseColor.rgb * ambientColor.rgb;\n}\nvec4 CCToonShading (ToonSurface s) {\n  Lighting result;\n  result.diffuse = vec3(0, 0, 0);\n  result.specular = vec3(0, 0, 0);\n  #if CC_NUM_LIGHTS > 0\n    #if CC_LIGHT_0_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[0]);\n    #else\n      LightInfo info0;\n      #if CC_LIGHT_0_TYPE == 0\n        info0 = computeDirectionalLighting(cc_lightDirection[0], cc_lightColor[0]);\n      #elif CC_LIGHT_0_TYPE == 1\n        info0 = computePointLighting(s.position, cc_lightPositionAndRange[0], cc_lightColor[0]);\n      #elif CC_LIGHT_0_TYPE == 2\n        info0 = computeSpotLighting(s.position, cc_lightPositionAndRange[0], cc_lightDirection[0], cc_lightColor[0]);\n      #endif\n      Lighting result0 = toon(s, info0);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n    float shadow_0 = 1.0;\n    vec2 projCoords0 = v_posLightSpace[0].xy / v_posLightSpace[0].w;\n    vec2 shadowUV0 = projCoords0 * 0.5 + vec2(0.5);\n    if (shadowUV0.x >= 0.0 && shadowUV0.x <= 1.0 && shadowUV0.y >= 0.0 && shadowUV0.y <= 1.0) {\n      float currentDepth0 = clamp(v_depth[0], 0.0, 1.0);\n      #if CC_SHADOW_0_TYPE == 3\n        shadow_0 = shadowPCF3X3(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w, cc_shadow_info[0].z);\n      #elif CC_SHADOW_0_TYPE == 4\n        shadow_0 = shadowPCF5X5(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w, cc_shadow_info[0].z);\n      #else\n        shadow_0 = shadowSimple(cc_shadow_map_0, shadowUV0, currentDepth0, cc_shadow_info[0].w);\n      #endif\n      shadow_0 = computeFallOff(shadow_0, projCoords0, 0.0);\n    }\n    result0.diffuse *= shadow_0;\n    result0.specular *= shadow_0;\n  #endif\n      result.diffuse += result0.diffuse;\n      result.specular += result0.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 1\n    #if CC_LIGHT_1_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[1]);\n    #else\n      LightInfo info1;\n      #if CC_LIGHT_1_TYPE == 0\n        info1 = computeDirectionalLighting(cc_lightDirection[1], cc_lightColor[1]);\n      #elif CC_LIGHT_1_TYPE == 1\n        info1 = computePointLighting(s.position, cc_lightPositionAndRange[1], cc_lightColor[1]);\n      #elif CC_LIGHT_1_TYPE == 2\n        info1 = computeSpotLighting(s.position, cc_lightPositionAndRange[1], cc_lightDirection[1], cc_lightColor[1]);\n      #endif\n      Lighting result1 = toon(s, info1);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 1\n    float shadow_1 = 1.0;\n    vec2 projCoords1 = v_posLightSpace[1].xy / v_posLightSpace[1].w;\n    vec2 shadowUV1 = projCoords1 * 0.5 + vec2(0.5);\n    if (shadowUV1.x >= 0.0 && shadowUV1.x <= 1.0 && shadowUV1.y >= 0.0 && shadowUV1.y <= 1.0) {\n      float currentDepth1 = clamp(v_depth[1], 0.0, 1.0);\n      #if CC_SHADOW_1_TYPE == 3\n        shadow_1 = shadowPCF3X3(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w, cc_shadow_info[1].z);\n      #elif CC_SHADOW_1_TYPE == 4\n        shadow_1 = shadowPCF5X5(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w, cc_shadow_info[1].z);\n      #else\n        shadow_1 = shadowSimple(cc_shadow_map_1, shadowUV1, currentDepth1, cc_shadow_info[1].w);\n      #endif\n      shadow_1 = computeFallOff(shadow_1, projCoords1, 0.0);\n    }\n    result1.diffuse *= shadow_1;\n    result1.specular *= shadow_1;\n  #endif\n      result.diffuse += result1.diffuse;\n      result.specular += result1.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 2\n    #if CC_LIGHT_2_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[2]);\n    #else\n      LightInfo info2;\n      #if CC_LIGHT_2_TYPE == 0\n        info2 = computeDirectionalLighting(cc_lightDirection[2], cc_lightColor[2]);\n      #elif CC_LIGHT_2_TYPE == 1\n        info2 = computePointLighting(s.position, cc_lightPositionAndRange[2], cc_lightColor[2]);\n      #elif CC_LIGHT_2_TYPE == 2\n        info2 = computeSpotLighting(s.position, cc_lightPositionAndRange[2], cc_lightDirection[2], cc_lightColor[2]);\n      #endif\n      Lighting result2 = toon(s, info2);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 2\n    float shadow_2 = 1.0;\n    vec2 projCoords2 = v_posLightSpace[2].xy / v_posLightSpace[2].w;\n    vec2 shadowUV2 = projCoords2 * 0.5 + vec2(0.5);\n    if (shadowUV2.x >= 0.0 && shadowUV2.x <= 1.0 && shadowUV2.y >= 0.0 && shadowUV2.y <= 1.0) {\n      float currentDepth2 = clamp(v_depth[2], 0.0, 1.0);\n      #if CC_SHADOW_2_TYPE == 3\n        shadow_2 = shadowPCF3X3(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w, cc_shadow_info[2].z);\n      #elif CC_SHADOW_2_TYPE == 4\n        shadow_2 = shadowPCF5X5(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w, cc_shadow_info[2].z);\n      #else\n        shadow_2 = shadowSimple(cc_shadow_map_2, shadowUV2, currentDepth2, cc_shadow_info[2].w);\n      #endif\n      shadow_2 = computeFallOff(shadow_2, projCoords2, 0.0);\n    }\n    result2.diffuse *= shadow_2;\n    result2.specular *= shadow_2;\n  #endif\n      result.diffuse += result2.diffuse;\n      result.specular += result2.specular;\n    #endif\n  #endif\n  #if CC_NUM_LIGHTS > 3\n    #if CC_LIGHT_3_TYPE == 3\n      result.diffuse += ambient(s, cc_lightColor[3]);\n    #else\n      LightInfo info3;\n      #if CC_LIGHT_3_TYPE == 0\n        info3 = computeDirectionalLighting(cc_lightDirection[3], cc_lightColor[3]);\n      #elif CC_LIGHT_3_TYPE == 1\n        info3 = computePointLighting(s.position, cc_lightPositionAndRange[3], cc_lightColor[3]);\n      #elif CC_LIGHT_3_TYPE == 2\n        info3 = computeSpotLighting(s.position, cc_lightPositionAndRange[3], cc_lightDirection[3], cc_lightColor[3]);\n      #endif\n      Lighting result3 = toon(s, info3);\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 3\n    float shadow_3 = 1.0;\n    vec2 projCoords3 = v_posLightSpace[3].xy / v_posLightSpace[3].w;\n    vec2 shadowUV3 = projCoords3 * 0.5 + vec2(0.5);\n    if (shadowUV3.x >= 0.0 && shadowUV3.x <= 1.0 && shadowUV3.y >= 0.0 && shadowUV3.y <= 1.0) {\n      float currentDepth3 = clamp(v_depth[3], 0.0, 1.0);\n      #if CC_SHADOW_3_TYPE == 3\n        shadow_3 = shadowPCF3X3(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w, cc_shadow_info[3].z);\n      #elif CC_SHADOW_3_TYPE == 4\n        shadow_3 = shadowPCF5X5(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w, cc_shadow_info[3].z);\n      #else\n        shadow_3 = shadowSimple(cc_shadow_map_3, shadowUV3, currentDepth3, cc_shadow_info[3].w);\n      #endif\n      shadow_3 = computeFallOff(shadow_3, projCoords3, 0.0);\n    }\n    result3.diffuse *= shadow_3;\n    result3.specular *= shadow_3;\n  #endif\n      result.diffuse += result3.diffuse;\n      result.specular += result3.specular;\n    #endif\n  #endif\n  vec3 finalColor = result.diffuse + result.specular + s.emissive;\n  return vec4(finalColor, s.baseColor.a);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if OUTPUT_TO_GAMMA\n    color.rgb = sqrt(color.rgb);\n  #endif\n\treturn color;\n}\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec3 v_viewDirection;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\nuniform vec4 specular;\nuniform vec4 emissive;\nuniform vec4 shadowColor;\nuniform vec4 highlightColor;\nuniform float specularThreshold;\nuniform float shadowIntensity;\nuniform float lightThreshold;\nuniform float lightSmoothness;\nvoid surf (out ToonSurface s) {\n  #if USE_BASE_COLOR_MAP\n    s.baseColor = vec4(1.);\n  vec4 baseColorMap_tmp = texture2D(baseColorMap, v_uv);\n  #if CC_USE_ALPHA_ATLAS_baseColorMap\n      baseColorMap_tmp.a *= texture2D(baseColorMap, v_uv + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    s.baseColor.rgb *= (baseColorMap_tmp.rgb * baseColorMap_tmp.rgb);\n    s.baseColor.a *= baseColorMap_tmp.a;\n  #else\n    s.baseColor *= baseColorMap_tmp;\n  #endif\n  #else\n    s.baseColor = highlightColor;\n  #endif\n  s.normal = normalize(v_normal);\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal = normalize(\n      nmmp.x * normalize(v_tangent) +\n      nmmp.y * normalize(v_bitangent) +\n      nmmp.z * s.normal);\n  #endif\n  s.position = v_position;\n  s.specular = specular.rgb * specular.a;\n  #if USE_SPECULAR_MAP\n  vec4 specularMap_tmp = texture2D(specularMap, v_uv);\n  #if CC_USE_ALPHA_ATLAS_specularMap\n      specularMap_tmp.a *= texture2D(specularMap, v_uv + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    s.specular.rgb *= (specularMap_tmp.rgb * specularMap_tmp.rgb);\n  #else\n    s.specular.rgb *= specularMap_tmp.rgb;\n  #endif\n  #endif\n  s.emissive = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n  vec4 emissiveMap_tmp = texture2D(emissiveMap, v_uv);\n  #if CC_USE_ALPHA_ATLAS_emissiveMap\n      emissiveMap_tmp.a *= texture2D(emissiveMap, v_uv + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    s.emissive.rgb *= (emissiveMap_tmp.rgb * emissiveMap_tmp.rgb);\n  #else\n    s.emissive.rgb *= emissiveMap_tmp.rgb;\n  #endif\n  #endif\n  s.lightThreshold = lightThreshold;\n  s.lightSmoothness = lightSmoothness;\n  s.shadowColor = shadowColor.rgb;\n  s.highlightColor = highlightColor.rgb;\n  s.shadowIntensity = shadowIntensity;\n  s.specularThreshold = specularThreshold;\n  s.viewDirection = v_viewDirection;\n}\nvec4 frag () {\n  ToonSurface s;\n  surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CC_SHADOW","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"CCLIGHTS","defines":["CC_NUM_LIGHTS"]}],"samplers":[{"name":"cc_shadow_map_0","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"cc_shadow_map_1","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]}]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_JOINTS_TEXTRUE","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"CC_JOINTS_TEXTURE_FLOAT32","type":"boolean","defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"CC_USE_ATTRIBUTE_UV0","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_COLOR","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_NORMAL","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_TANGENT","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"CC_USE_SHADOW_MAP","type":"boolean","defines":[]},{"name":"CC_NUM_SHADOW_LIGHTS","type":"number","defines":["CC_USE_SHADOW_MAP"],"range":[0,3]},{"name":"CC_NUM_LIGHTS","type":"number","defines":[],"range":[0,3]},{"name":"CC_LIGHT_0_TYPE","type":"number","defines":["CC_NUM_LIGHTS"],"range":[0,3]},{"name":"CC_SHADOW_0_TYPE","type":"number","defines":["CC_NUM_LIGHTS","CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"],"range":[0,3]},{"name":"CC_LIGHT_1_TYPE","type":"number","defines":["CC_NUM_LIGHTS"],"range":[0,3]},{"name":"CC_SHADOW_1_TYPE","type":"number","defines":["CC_NUM_LIGHTS","CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"],"range":[0,3]},{"name":"CC_LIGHT_2_TYPE","type":"number","defines":["CC_NUM_LIGHTS"],"range":[0,3]},{"name":"CC_SHADOW_2_TYPE","type":"number","defines":["CC_NUM_LIGHTS","CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"],"range":[0,3]},{"name":"CC_LIGHT_3_TYPE","type":"number","defines":["CC_NUM_LIGHTS"],"range":[0,3]},{"name":"CC_SHADOW_3_TYPE","type":"number","defines":["CC_NUM_LIGHTS","CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"],"range":[0,3]},{"name":"OUTPUT_TO_GAMMA","type":"boolean","defines":[]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]},{"name":"USE_SPECULAR_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_baseColorMap","type":"boolean","defines":["USE_BASE_COLOR_MAP"]},{"name":"INPUT_IS_GAMMA","type":"boolean","defines":["USE_BASE_COLOR_MAP"]},{"name":"CC_USE_ALPHA_ATLAS_specularMap","type":"boolean","defines":["USE_SPECULAR_MAP"]},{"name":"CC_USE_ALPHA_ATLAS_emissiveMap","type":"boolean","defines":["USE_EMISSIVE_MAP"]}],"blocks":[{"name":"SKINNING","binding":0,"members":[{"name":"jointsTextureSize","type":14,"count":1}],"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"JOINT_MATRIX","binding":1,"members":[{"name":"jointMatrices","type":26,"count":50}],"defines":["CC_USE_SKINNING"]},{"name":"ToonVert","binding":2,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":[]},{"name":"ToonFrag","binding":3,"members":[{"name":"colorScale","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"shadowColor","type":16,"count":1},{"name":"highlightColor","type":16,"count":1},{"name":"specularThreshold","type":13,"count":1},{"name":"shadowIntensity","type":13,"count":1},{"name":"lightThreshold","type":13,"count":1},{"name":"lightSmoothness","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"jointsTexture","type":29,"count":1,"binding":30,"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"normalMap","type":29,"count":1,"binding":31,"defines":["USE_NORMAL_MAP"]},{"name":"baseColorMap","type":29,"count":1,"binding":32,"defines":["USE_BASE_COLOR_MAP"]},{"name":"specularMap","type":29,"count":1,"binding":33,"defines":["USE_SPECULAR_MAP"]},{"name":"emissiveMap","type":29,"count":1,"binding":34,"defines":["USE_EMISSIVE_MAP"]}]}],[{"passes":[{"name":"outline","program":"builtin-toon|outline-vs:vert|outline-fs:frag","rasterizerState":{"cullMode":1028},"depthStencilState":{"depthTest":true,"depthWrite":true},"properties":{"lineWidth":{"type":13,"value":[10]},"depthBias":{"type":13,"value":[0]},"outlineBaseColor":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"outlineBaseColorMap":{"value":"gray","type":29}}},{"name":"toon","program":"builtin-toon|toon-vs:vert|toon-fs:frag","depthStencilState":{"depthTest":true,"depthWrite":true},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalMap":{"value":"normal","type":29},"baseColorMap":{"value":"white","type":29},"specular":{"type":16,"value":[1,1,1,0.5],"editor":{"type":"color"}},"specularMap":{"value":"white","type":29},"specularThreshold":{"type":13,"value":[0.5]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveMap":{"value":"white","type":29},"shadowColor":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"shadowIntensity":{"type":13,"value":[0.5]},"highlightColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"lightThreshold":{"type":13,"value":[0.5]},"lightSmoothness":{"type":13,"value":[0.1]}}}]}]]],0,0,[],[],[]],[[{"name":"default_radio_button_off","rect":[3,3,26,26],"offset":[0,0],"originalSize":[32,32],"capInsets":[0,0,0,0]}],[1],0,[0],[5],[109]],[[[10,".bin",[[11,4,[12,128],[[1,"a_normal",5126,3],[1,"a_position",5126,3],[1,"a_uv0",5126,2]]]],[[14,[0],[13,128,12]]],[1,-0.5,-0.5,0],[1,0.5,0.5,0]],-1],0,0,[],[],[]],[[[2,"3d-stage"],[31,"New 3D Stage",true,[-2,-3,-4,-5],[0,"38R8VzTKlGM4vBvAyA2GaF",-1]],[53,"3D Camera",512,true,1,[[43,1024,false,false,-6]],[0,"09OTSCM6BL1LhNz6/uluXk",1],[0,0,10,0,0,0,1,1,1,1]],[54,"New Directional Light",512,true,1,[[37,1000,50,-7]],[0,"3a6x6Es1NL4rpUC3Efs1MH",1],[0,0,0,-0.25881904510252074,0,0,0.9659258262890683,1,1,1],[1,-30,0,0]],[55,"New Ambient Light",512,true,1,[[36,3,0.25,1,1000,50,-8]],[0,"77dtDtUX9D6KSMMqNy4utl",1]],[56,"New Box",true,1,[[4,-9,[0],1]],[0,"53C6mOUF5FXpk7lkLCsXQc",1]]],0,[0,1,1,0,-1,2,0,-2,3,0,-3,4,0,-4,5,0,0,2,0,0,3,0,0,4,0,0,5,0,2,1,9],[0,0],[-1,4],[1,7]],[[[2,"spot"],[19,"light",true,[[35,2,1000,50,-2]],[0,"33zOkteexCqamZ4PXuwJaW",-1],[0,0,0,0,0,0,0,1,1,1]]],0,[0,1,1,0,0,1,0,2,1,2],[],[],[]],[[[2,"capsule"],[7,"capsule",true,[[4,-2,[0],1]],[0,"03MuJmYVpF+Kz929rGKeef",-1]]],0,[0,1,1,0,0,1,0,2,1,2],[0,0],[-1,4],[1,11]]]]